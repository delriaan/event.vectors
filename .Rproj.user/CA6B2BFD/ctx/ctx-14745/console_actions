{
    "type": [
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2
    ],
    "data": [
        "> ",
        "signal_processor <- function(object, ..., nfolds = 1, cl_size = 1, .debug = FALSE){",
        "+ ",
        "\t#' Signal Processor",
        "+ ",
        "\t#'",
        "+ ",
        "\t#' @param object A \"break_signal\" \\code{\\link{S7}} object",
        "+ ",
        "\t#' @param ... (Ignored)",
        "+ ",
        "\t#' @param nfolds Number of folds to use during data generation and scoring",
        "+ ",
        "\t#' @param cl Cluster object created from package \\code{parallelly}",
        "+ ",
        "\t#'",
        "+ ",
        "\t#' @return The original \"break_signal\" object with prescribed slots populated from the results of processing the \"signal\" (see \\code{\\link{break_signal}})",
        "+ ",
        "\t#'",
        "+ ",
        "\t#' @export",
        "+ ",
        "\tS7::check_is_S7(object);",
        "+ ",
        "",
        "+ ",
        "\t# :: User argument handling ====",
        "+ ",
        "\ty <- object@y;",
        "+ ",
        "\ty_grp <- object@grp;",
        "+ ",
        "",
        "+ ",
        "\tobs_ctrl <- object@obs_ctrl |>",
        "+ ",
        "\t\tpurrr::modify_at(\"min_size\", \\(x) magrittr::set_attr(x, \"label\", \"Minimum grouped size to process\")) |>",
        "+ ",
        "\t\tpurrr::modify_at(\"max_k\", \\(x) magrittr::set_attr(x, \"label\", \"Maximum break allowed: \\nrequires domain knowledge as this is an emperical-analytic task\"))",
        "+ ",
        "",
        "+ ",
        "\t# :: Function definitions ====",
        "+ ",
        "\t# Information encoder",
        "+ ",
        "\tinfo_encoder <- function(i, info.only = FALSE, data.only = info.only){",
        "+ ",
        "\t\t# Encode Shannon Information",
        "+ ",
        "\t\t#",
        "+ ",
        "\t\t# \\code{info_encoder} converts the \\code{i} into distinct series based on monotonically occurring breaks.\\cr",
        "+ ",
        "\t\t# The cumulative proportionality within each series is converted into Shannon information as \"bits\".",
        "+ ",
        "\t\t# @note \\code{info_encoder()} requires the input to be the differences of an \\emph{ordered} vector",
        "+ ",
        "\t\t#",
        "+ ",
        "\t\t# @param i (numeric) The input vector of differences",
        "+ ",
        "\t\t# @param info.only (logical) \\code{TRUE} returns the information column only",
        "+ ",
        "\t\t# @param data.only (logical) \\code{TRUE} returns columns \\code{series} and \\code{cyl} only, and \\code{FALSE} returns everything",
        "+ ",
        "\t\t#",
        "+ ",
        "",
        "+ ",
        "\t\tis_signal_break <- c(0, diff(i)) < 0;",
        "+ ",
        "",
        "+ ",
        "\t\tsignal_data <- data.table::data.table(",
        "+ ",
        "\t\t\tdy = i",
        "+ ",
        "\t\t\t, cyl = book.of.utilities::count.cycles(is_signal_break, reset = FALSE)",
        "+ ",
        "\t\t)[, series := sum(dy), by = cyl]",
        "+ ",
        "",
        "+ ",
        "\t\tinform <- \\(x, z){",
        "+ ",
        "\t\t\t# Use each value of `x` (differences) to condition `z` (series) when `x` is",
        "+ ",
        "\t\t\t# less than or equal to the current value `i`.  The result is converted",
        "+ ",
        "\t\t\t# into an information bit.",
        "+ ",
        "\t\t\tsapply(x, \\(i){",
        "+ ",
        "\t\t\t\tbook.of.utilities::ratio(x <= i, type = \"cumulative\", d = 6) |>",
        "+ ",
        "\t\t\t\t\tlog(base = 2) |>",
        "+ ",
        "\t\t\t\t\tmagrittr::multiply_by(-1) |>",
        "+ ",
        "\t\t\t\t\tsum(na.rm = TRUE)",
        "+ ",
        "\t\t\t})",
        "+ ",
        "\t\t}",
        "+ ",
        "",
        "+ ",
        "\t\tif (info.only){",
        "+ ",
        "\t\t\tsignal_data[, .(info = inform(dy, series)), by = cyl][, .(info)]",
        "+ ",
        "\t\t} else {",
        "+ ",
        "\t\t\tif (data.only){",
        "+ ",
        "\t\t\t\tsignal_data[, !c(\"dy\")]",
        "+ ",
        "\t\t\t} else {",
        "+ ",
        "\t\t\t\tsignal_data[, info := inform(dy, series), by = cyl][, !c(\"dy\")]",
        "+ ",
        "\t\t\t}",
        "+ ",
        "\t\t}",
        "+ ",
        "\t}",
        "+ ",
        "",
        "+ ",
        "\t# Geometric PMF",
        "+ ",
        "\tgeo_pmf <- function(x, p){",
        "+ ",
        "\t\t# Geometric Probability Mass Function",
        "+ ",
        "\t\t#",
        "+ ",
        "\t\t# @param x The cumulative sum of differences, representing the number of attempts before success.\\cr These values imply contiguous parts of the series before a break.",
        "+ ",
        "\t\t# @param p The cumulative proportion of the current group's difference-proportion mapped from `response.pmf`.",
        "+ ",
        "\t\t#",
        "+ ",
        "\t\t# @return \\code{p * (1 - p)^x}",
        "+ ",
        "",
        "+ ",
        "\t\tassertive::assert_all_are_in_left_open_range(x = p, lower = 0, upper = 1, na_ignore = TRUE, severity = \"stop\")",
        "+ ",
        "\t\tassertive::assert_all_are_greater_than_or_equal_to(x = x, y = 0, severity = \"stop\")",
        "+ ",
        "\t\tp * (1 - p)^x;",
        "+ ",
        "\t}",
        "+ ",
        "",
        "+ ",
        "\t# Algorithm engine definition",
        "+ ",
        "\texec_algorithm <- function(Data, nfolds){",
        "+ ",
        "\t\t# Execute Algorithm",
        "+ ",
        "\t\t#",
        "+ ",
        "\t\t# @param Data The input data",
        "+ ",
        "\t\t# @param nfolds THe number of cross-assignment folds",
        "+ ",
        "\t\t#",
        "+ ",
        "\t\t# @return A \\code{\\link[data.table]{data.table}} object containing folded data generation and scoring",
        "+ ",
        "",
        "+ ",
        "\t\tassertive::assert_all_are_greater_than_or_equal_to(nfolds, 1, severity = \"stop\");",
        "+ ",
        "",
        "+ ",
        "\t\tif (nfolds == 1){ nfolds <- min(c(5, Data$grp |> data.table::uniqueN())) }",
        "+ ",
        "\t\tfold_map <- data.table::data.table(seq_len(nfolds), Data$grp |> unique()) |> data.table::setnames(c(\"fold_id\", \"grp\"));",
        "+ ",
        "",
        "+ ",
        "\t\tX <- Data[",
        "+ ",
        "\t\t\t, `:=`(c(\"cyl\", \"series\", \"grp.info\")",
        "+ ",
        "\t\t\t\t\t\t # Encode information ====",
        "+ ",
        "\t\t\t\t\t\t , info_encoder(dy, info.only = FALSE))",
        "+ ",
        "\t\t\t, by = grp",
        "+ ",
        "\t\t][",
        "+ ",
        "\t\t\t# Assign CV folds gy group identifier ====",
        "+ ",
        "\t\t\tfold_map, on = \"grp\", fold_id := fold_id, by = .EACHI",
        "+ ",
        "\t\t];",
        "+ ",
        "",
        "+ ",
        "\t\t# Generate and score data by fold exclusion ====",
        "+ ",
        "\t\tfold_map$fold_id |>",
        "+ ",
        "\t\t\tunique() |>",
        "+ ",
        "\t\t\trlang::set_names() |>",
        "+ ",
        "\t\t\tpurrr::map(\\(exclude_fold_id){",
        "+ ",
        "\t\t\t\tX[(!fold_id %in% exclude_fold_id)][",
        "+ ",
        "\t\t\t\t\t, `:=`(",
        "+ ",
        "\t\t\t\t\t\t# Within-group cumulative \"attempts\" subsequently passed to geometric PMF calculation ====",
        "+ ",
        "\t\t\t\t\t\tk = cumsum(dy)",
        "+ ",
        "\t\t\t\t\t\t, grp.info = (\\(arg){",
        "+ ",
        "\t\t\t\t\t\t\tif (any(is.infinite(arg))){",
        "+ ",
        "\t\t\t\t\t\t\t\targ[is.infinite(arg)] <- max(arg[!is.infinite(arg)]);",
        "+ ",
        "\t\t\t\t\t\t\t}",
        "+ ",
        "\t\t\t\t\t\t\targ;",
        "+ ",
        "\t\t\t\t\t\t})(grp.info)",
        "+ ",
        "\t\t\t\t\t)",
        "+ ",
        "\t\t\t\t\t, by = .(cyl, grp)",
        "+ ",
        "\t\t\t\t][",
        "+ ",
        "\t\t\t\t\t# Within-group geometric PMF and break information deviation ====",
        "+ ",
        "\t\t\t\t\t, `:=`(geo_pmf = geo_pmf(x = k, p = p)",
        "+ ",
        "\t\t\t\t\t\t\t\t , Idev = (info - grp.info)^2",
        "+ ",
        "\t\t\t\t\t)",
        "+ ",
        "\t\t\t\t\t, by = .(cyl, grp)",
        "+ ",
        "\t\t\t\t][",
        "+ ",
        "\t\t\t\t\t, .(cyl, grp, series, k, info, geo_pmf, Idev)",
        "+ ",
        "\t\t\t\t][",
        "+ ",
        "\t\t\t\t\t# Within-group break-cycle information deviation slope ====",
        "+ ",
        "\t\t\t\t\t, d_Idev := c(0, diff(Idev))",
        "+ ",
        "\t\t\t\t\t, by = .(cyl, grp)",
        "+ ",
        "\t\t\t\t][",
        "+ ",
        "\t\t\t\t\t# Within-group break-cycle information deviation curvature ====",
        "+ ",
        "\t\t\t\t\t, d2_Idev := c(0, diff(d_Idev))",
        "+ ",
        "\t\t\t\t\t, by = .(cyl, grp)",
        "+ ",
        "\t\t\t\t] |>",
        "+ ",
        "\t\t\t\t\tscore_algorithm_output()",
        "+ ",
        "\t\t\t}) |>",
        "+ ",
        "\t\t\t# Combine data and return",
        "+ ",
        "\t\t\tdata.table::rbindlist(idcol = \"exclude_fold_id\");",
        "+ ",
        "\t}",
        "+ ",
        "",
        "+ ",
        "\t# Scoring function definition",
        "+ ",
        "\tscore_algorithm_output <- function(algo_output){",
        "+ ",
        "\t\t# Score Algorithm Output",
        "+ ",
        "\t\t#",
        "+ ",
        "\t\t# @param algo_output The algorithm output created from \\code{exec_algorithm}",
        "+ ",
        "\t\t#",
        "+ ",
        "\t\t#",
        "+ ",
        "\t\talgo_output[",
        "+ ",
        "\t\t\t# Filter criteria ====",
        "+ ",
        "\t\t\t(k <= obs_ctrl$max_k) &",
        "+ ",
        "\t\t\t\t(k > 0) &",
        "+ ",
        "\t\t\t\t(d_Idev >= 0) & # Increasing or constant",
        "+ ",
        "\t\t\t\t(d2_Idev <= 0) # Concave or local maximum",
        "+ ",
        "\t\t\t, .(",
        "+ ",
        "\t\t\t\t# Break score (k_score): information deviation equation/model ====",
        "+ ",
        "\t\t\t\tk_score = (\\(g, EX){",
        "+ ",
        "\t\t\t\t\tEX[g == max(g, na.rm = TRUE)] |>",
        "+ ",
        "\t\t\t\t\t\tmean(na.rm = TRUE) |>",
        "+ ",
        "\t\t\t\t\t\tmagrittr::multiply_by(.N >= obs_ctrl$min_size) |>",
        "+ ",
        "\t\t\t\t\t\tmagrittr::add(1) |>",
        "+ ",
        "\t\t\t\t\t\tlog(base = 2)",
        "+ ",
        "\t\t\t\t})(g = geo_pmf, EX = geo_pmf * Idev)",
        "+ ",
        "\t\t\t\t# Observations per `k` ====",
        "+ ",
        "\t\t\t\t, k_sz = .N",
        "+ ",
        "\t\t\t\t, geo_pmf.max = max(geo_pmf, na.rm = TRUE)",
        "+ ",
        "\t\t\t\t# PMF-weighted mean of break information deviation ====",
        "+ ",
        "\t\t\t\t# This derives the expected value of squared information deviation (`Idev`)",
        "+ ",
        "\t\t\t\t#   and is used to find the optimal `k`",
        "+ ",
        "\t\t\t\t, Idev_wmean = weighted.mean(Idev, geo_pmf, na.rm = TRUE)",
        "+ ",
        "\t\t\t)",
        "+ ",
        "\t\t\t, by = k",
        "+ ",
        "\t\t][",
        "+ ",
        "\t\t\t# Interim row filter and data subset preparation ====",
        "+ ",
        "\t\t\t(k_score > 0)",
        "+ ",
        "\t\t\t, .SD[order(k, k_score)] |> unique()",
        "+ ",
        "\t\t][",
        "+ ",
        "\t\t\t# Slope (d'/dk) ====",
        "+ ",
        "\t\t\t, `:=`(d_kscore = c(0, diff(k_score))/c(1, diff(k))",
        "+ ",
        "\t\t\t\t\t\t , d_Idev_wmean = c(0, diff(Idev_wmean))/c(1, diff(k))",
        "+ ",
        "\t\t\t)",
        "+ ",
        "\t\t][",
        "+ ",
        "\t\t\t# Curvature (d\"/dk) ====",
        "+ ",
        "\t\t\t, `:=`(d2_kscore = c(0, diff(d_kscore))",
        "+ ",
        "\t\t\t\t\t\t , d2_Idev_wmean = c(0, diff(d_Idev_wmean))",
        "+ ",
        "\t\t\t)",
        "+ ",
        "\t\t][",
        "+ ",
        "\t\t\t# Total Score ===",
        "+ ",
        "\t\t\t# `tot_score` is the mutual relative proportionality of curvatures over `k` and `Idev_wmean`",
        "+ ",
        "\t\t\t, `:=`(tot_score = (1 - book.of.utilities::ratio(abs(d2_Idev_wmean), type = \"of.max\", d = 6)) *",
        "+ ",
        "\t\t\t\t\t\t \tbook.of.utilities::ratio(d2_kscore, type = \"of.max\", d = 6))",
        "+ ",
        "\t\t][",
        "+ ",
        "\t\t\t, `:=`(",
        "+ ",
        "\t\t\t\t# \"Best\" and alternate break values derivation ====",
        "+ ",
        "\t\t\t\tbest_k = k[tot_score == max(tot_score, na.rm = TRUE)] |> unique()",
        "+ ",
        "\t\t\t\t, alt_k = k * (book.of.utilities::ratio(tot_score, type = \"cumulative\", d = 6) >= 0.9) *",
        "+ ",
        "\t\t\t\t\t(tot_score != max(tot_score, na.rm = TRUE))",
        "+ ",
        "\t\t\t)",
        "+ ",
        "\t\t];",
        "+ ",
        "\t}",
        "+ ",
        "",
        "+ ",
        "\t# :: Grouped differentials of the observed measurements ====",
        "+ ",
        "\tgrouped_response <- split(y, f = y_grp) |>",
        "+ ",
        "\t\tlapply(\\(i) list(dy = c(0, diff(as.numeric(i))))) %>%",
        "+ ",
        "\t\t.[sapply(., \\(x) length(unlist(x)) >= obs_ctrl$min_size)] |>",
        "+ ",
        "\t\tdata.table::rbindlist(idcol = \"grp\") |>",
        "+ ",
        "\t\tdplyr::filter(dy > 0)",
        "+ ",
        "",
        "+ ",
        "\tobject@k <- grouped_response$dy;",
        "+ ",
        "",
        "+ ",
        "\t# :: Proportional response values & information encoding ====",
        "+ ",
        "\tresponse.pmf <- table(grouped_response$dy) %>% magrittr::divide_by(sum(., na.rm = TRUE));",
        "+ ",
        "\tresponse.pmf <- response.pmf[as.numeric(names(response.pmf)) |> order()] |>",
        "+ ",
        "\t\tdata.table::as.data.table() |>",
        "+ ",
        "\t\tdata.table::setnames(c(\"dy\", \"p\")) |>",
        "+ ",
        "\t\tpurrr::modify_at(\"dy\", as.numeric);",
        "+ ",
        "",
        "+ ",
        "\tspsUtil::quiet(response.pmf[, info := -log(p)]);",
        "+ ",
        "",
        "+ ",
        "\t# Merge `response.pmf` into `grouped_response`",
        "+ ",
        "\tspsUtil::quiet(grouped_response[response.pmf, on = \"dy\", `:=`(p = i.p, info = i.info), by = .EACHI]);",
        "+ ",
        "",
        "+ ",
        "\t# :: Parallelism topography (depends on user argument `cl_size`) ====",
        "+ ",
        "\t.logi_vec <- (cl_size > 1L) & (data.table::uniqueN(grouped_response$g) > 1);",
        "+ ",
        "",
        "+ ",
        "\tif (.logi_vec){",
        "+ ",
        "\t\t# Global assignment to allow for manual termination",
        "+ ",
        "\t\tcl <- parallelly::makeClusterPSOCK(workers = cl_size, autoStop = TRUE, );",
        "+ ",
        "",
        "+ ",
        "\t\tparallel::clusterSetRNGStream(cl = cl, sample(-1E5:1E5, 1));",
        "+ ",
        "",
        "+ ",
        "\t\tparallel::clusterExport(",
        "+ ",
        "\t\t\tcl = cl",
        "+ ",
        "\t\t\t, varlist = c(\"info_encoder\", \"geo_pmf\", \"exec_algorithm\", \"score_algorithm_output\", \"nfolds\", \"response.pmf\")",
        "+ ",
        "\t\t\t, envir = environment()",
        "+ ",
        "\t\t\t);",
        "+ ",
        "",
        "+ ",
        "\t\tspsUtil::quiet({",
        "+ ",
        "\t\t\tparallel::clusterSplit(cl = cl, seq = unique(grouped_response$g)) |>",
        "+ ",
        "\t\t\t\tpurrr::walk(\\(grps){",
        "+ ",
        "\t\t\t\t\trlang::expr(parallel::clusterEvalQ(cl = cl, expr = {",
        "+ ",
        "\t\t\t\t\t\tlibrary(magrittr);",
        "+ ",
        "\t\t\t\t\t\tlibrary(book.of.workflow);",
        "+ ",
        "\t\t\t\t\t\tlibrary(data.table);",
        "+ ",
        "\t\t\t\t\t\tlibrary(book.of.utilities);",
        "+ ",
        "",
        "+ ",
        "\t\t\t\t\t\trm(list = c(\"X\")[exists(\"X\")]);",
        "+ ",
        "",
        "+ ",
        "\t\t\t\t\t\tgrouped_response <- !!data.table::as.data.table(grouped_response[(grp %in% grps)]);",
        "+ ",
        "\t\t\t\t\t})) |> eval();",
        "+ ",
        "\t\t\t\t});",
        "+ ",
        "\t\t});",
        "+ ",
        "",
        "+ ",
        "\t\tcat(\"[INFO] Created cluster `cl` in the calling environment\\n\");",
        "+ ",
        "\t}",
        "+ ",
        "",
        "+ ",
        "\t# :: Derive resultant dataset ====",
        "+ ",
        "\tif (.debug){ browser(); }",
        "+ ",
        "",
        "+ ",
        "\t.temp <- if (.logi_vec){",
        "+ ",
        "\t\tspsUtil::quiet({",
        "+ ",
        "\t\t\tparallel::clusterEvalQ(cl = cl, exec_algorithm(data.table::copy(grouped_response), nfolds = nfolds)) |>",
        "+ ",
        "\t\t\t\tpurrr::compact() |>",
        "+ ",
        "\t\t\t\tdata.table::rbindlist()",
        "+ ",
        "\t\t})",
        "+ ",
        "\t} else {",
        "+ ",
        "\t\texec_algorithm(data.table::copy(grouped_response), nfolds = nfolds);",
        "+ ",
        "\t}",
        "+ ",
        "",
        "+ ",
        "\t# :: Greedy selection of `best_k` ====",
        "+ ",
        "\tscored_result <- .temp[(best_k == max(na.rm = TRUE, table(best_k) |> sort(decreasing = TRUE) |> names() |> data.table::first()))];",
        "+ ",
        "",
        "+ ",
        "\t# :: Assign scored results to S7 object, clean up, and return the object invisibly ====",
        "+ ",
        "\tobject@obs_ctrl <- obs_ctrl;",
        "+ ",
        "\tobject@best_k <- scored_result[1, best_k];",
        "+ ",
        "\tobject@alt_k <- scored_result[(alt_k > 0), alt_k |> sort()];",
        "+ ",
        "\tobject@k_sz <- scored_result$k_sz;",
        "+ ",
        "\tobject@score <- scored_result$k_score;",
        "+ ",
        "\tobject@data <- scored_result;",
        "+ ",
        "",
        "+ ",
        "\tif (!rlang::is_empty(cl_size) & (\"cl\" %in% ls())){",
        "+ ",
        "\t\tparallel::stopCluster(cl);",
        "+ ",
        "\t\trm(list = cl[!rlang::is_empty(find(\"cl\"))])",
        "+ ",
        "\t}",
        "+ ",
        "\treturn(invisible(object));",
        "+ ",
        "}",
        "\nRestarting R session...\n\n\nRestarting R session...\n\n"
    ]
}