names() |>
as.integer()
};
# Resolve the row data
rlang::list2(!!src := rlang::eval_tidy(attr(lazy_refs, "src.def"))[row_idx])
# }) |>
}, .options = .furrr_opts) |>
purrr::flatten() %>%
.[!duplicated(names(.))]
}
#
# ~ Validation #4 :: retrace.evs ====
retrace.evs(test.evs$evt_graphs[[1]], test.evs)
retrace.evs <- function(event_graph, evs){
#' Retrace Events to Source
#'
#' \code{retrace.evs} uses the input graph and reference \code{event.vectors} object to return the source data rows corresponding to the event vertices.
#'
#' @param event_graph A graph contained within \code{$evt_graphs} (use the \code{`[[`} primitive if using a numeric index; otherwise, use \code{`$`})
#' @param evs An object of class \code{event.vectors}
#'
#' @return A list of distinct rows that map to the source event data.  Event graph vertex names can be used to subset the output.
#'
#' @export
.haystack <- igraph::edge.attributes(event_graph) %$%
mget(c("jk", "src.pair", "from.coord", "to.coord")) |>
purrr::modify_at(c("from.coord", "to.coord"), stringi::stri_split_regex, "([:])|( -> )", simplify = TRUE) |>
list2env(envir = new.env());
# `.events` should be an array with dimensions N x 2
.events <- .haystack$src.pair |> stringi::stri_split_fixed(" -> ", simplify = TRUE);
.haystack$from.src <- .events[, 1];
.haystack$to.src <- .events[, 2];
.needle <- {
rlang::exprs(
jk = mget(ls(pattern = "jk$")) |> purrr::reduce(c)
, src = mget(ls(pattern = "src$")) |> purrr::reduce(c)
, time_start_idx = mget(ls(pattern = "^from.+coord")) |> purrr::reduce(c)
, time_end_idx = mget(ls(pattern = "^to.+coord")) |> purrr::reduce(c)
)}
# Find each "needle" in the "haystack"
.furrr_opts <- furrr::furrr_options(
scheduling = Inf
, packages = c("event.vectors", "data.table", "magrittr", "rlang")
, globals = c("evs")
);
purrr::map(.needle, eval, envir = .haystack) |>
# data.table::as.data.table() |>
# purrr::pmap(~{
furrr::future_map(\(x){
lazy_refs <- evs$config[[stringi::stri_replace_first_regex(x[2], "[:][0-9]+", "")]];
src <- x[2];
# Determine which row from the source data maps to the arguments
row_idx <- { lazy_refs %$%
purrr::map2(
.x = mget(c("jk", "time_start_idx", "time_end_idx"))
, .y = list(x[1], x[3], x[4])
, ~which(rlang::eval_tidy(.x) == .y)
) |>
unlist() |>
# Frequency Table
table() |>
# Sort decreasing
sort(decreasing = TRUE) |>
# Index of largest value is the correct row of the filtered source data
magrittr::extract(1) |>
names() |>
as.integer()
};
# Resolve the row data
rlang::list2(!!src := rlang::eval_tidy(attr(lazy_refs, "src.def"))[row_idx])
# }) |>
}, .options = .furrr_opts) |>
purrr::flatten() %>%
.[!duplicated(names(.))]
}
#
# ~ Validation #4 :: retrace.evs ====
retrace.evs(test.evs$evt_graphs[[1]], test.evs)
retrace.evs <- function(event_graph, evs){
#' Retrace Events to Source
#'
#' \code{retrace.evs} uses the input graph and reference \code{event.vectors} object to return the source data rows corresponding to the event vertices.
#'
#' @param event_graph A graph contained within \code{$evt_graphs} (use the \code{`[[`} primitive if using a numeric index; otherwise, use \code{`$`})
#' @param evs An object of class \code{event.vectors}
#'
#' @return A list of distinct rows that map to the source event data.  Event graph vertex names can be used to subset the output.
#'
#' @export
.haystack <- igraph::edge.attributes(event_graph) %$%
mget(c("jk", "src.pair", "from.coord", "to.coord")) |>
purrr::modify_at(c("from.coord", "to.coord"), stringi::stri_split_regex, "([:])|( -> )", simplify = TRUE) |>
list2env(envir = new.env());
# `.events` should be an array with dimensions N x 2
.events <- .haystack$src.pair |> stringi::stri_split_fixed(" -> ", simplify = TRUE);
.haystack$from.src <- .events[, 1];
.haystack$to.src <- .events[, 2];
.needle <- {
rlang::exprs(
jk = mget(ls(pattern = "jk$")) |> purrr::reduce(c)
, src = mget(ls(pattern = "src$")) |> purrr::reduce(c)
, time_start_idx = mget(ls(pattern = "^from.+coord")) |> purrr::reduce(c)
, time_end_idx = mget(ls(pattern = "^to.+coord")) |> purrr::reduce(c)
)}
# Find each "needle" in the "haystack"
.furrr_opts <- furrr::furrr_options(
scheduling = Inf
, packages = c("event.vectors", "data.table", "magrittr", "rlang")
, globals = c("evs")
);
.needle <- purrr::map(.needle, eval, envir = .haystack);
# data.table::as.data.table() |>
# purrr::pmap(~{
.needle |>
furrr::future_pmap(~{
lazy_refs <- evs$config[[stringi::stri_replace_first_regex(..2, "[:][0-9]+", "")]];
src <- ..2;
# Determine which row from the source data maps to the arguments
row_idx <- { lazy_refs %$%
purrr::map2(
.x = mget(c("jk", "time_start_idx", "time_end_idx"))
, .y = list(..1, ..3, ..4)
, ~which(rlang::eval_tidy(.x) == .y)
) |>
unlist() |>
# Frequency Table
table() |>
# Sort decreasing
sort(decreasing = TRUE) |>
# Index of largest value is the correct row of the filtered source data
magrittr::extract(1) |>
names() |>
as.integer()
}
# Resolve the row data
rlang::list2(!!src := rlang::eval_tidy(attr(lazy_refs, "src.def"))[row_idx])
# }) |>
}, .options = .furrr_opts) |>
purrr::flatten() %>%
.[!duplicated(names(.))]
}
# ~ Cleanup ====
plan(sequential);
gc(full = TRUE)
plan(tweak(multisession, workers = 3));
#
# ~ Validation #4 :: retrace.evs ====
retrace.evs(test.evs$evt_graphs[[1]], test.evs)
retrace.evs <- function(event_graph, evs){
#' Retrace Events to Source
#'
#' \code{retrace.evs} uses the input graph and reference \code{event.vectors} object to return the source data rows corresponding to the event vertices.
#'
#' @param event_graph A graph contained within \code{$evt_graphs} (use the \code{`[[`} primitive if using a numeric index; otherwise, use \code{`$`})
#' @param evs An object of class \code{event.vectors}
#'
#' @return A list of distinct rows that map to the source event data.  Event graph vertex names can be used to subset the output.
#'
#' @export
.haystack <- igraph::edge.attributes(event_graph) %$%
mget(c("jk", "src.pair", "from.coord", "to.coord")) |>
purrr::modify_at(c("from.coord", "to.coord"), stringi::stri_split_regex, "([:])|( -> )", simplify = TRUE) |>
list2env(envir = new.env());
# `.events` should be an array with dimensions N x 2
.events <- .haystack$src.pair |> stringi::stri_split_fixed(" -> ", simplify = TRUE);
.haystack$from.src <- .events[, 1];
.haystack$to.src <- .events[, 2];
.needle <- {
rlang::exprs(
jk = mget(ls(pattern = "jk$")) |> purrr::reduce(c)
, src = mget(ls(pattern = "src$")) |> purrr::reduce(c)
, time_start_idx = mget(ls(pattern = "^from.+coord")) |> purrr::reduce(c)
, time_end_idx = mget(ls(pattern = "^to.+coord")) |> purrr::reduce(c)
)}
# Find each "needle" in the "haystack"
.furrr_opts <- furrr::furrr_options(
scheduling = Inf
, packages = c("event.vectors", "data.table", "magrittr", "rlang")
, globals = c("evs")
);
.needle <- purrr::map(.needle, eval, envir = .haystack);
# data.table::as.data.table() |>
# purrr::pmap(~{
.needle |>
furrr::future_map(~{
lazy_refs <- evs$config[[stringi::stri_replace_first_regex(..2, "[:][0-9]+", "")]];
src <- ..2;
# Determine which row from the source data maps to the arguments
row_idx <- { lazy_refs %$%
purrr::map2(
.x = mget(c("jk", "time_start_idx", "time_end_idx"))
, .y = list(..1, ..3, ..4)
, ~which(rlang::eval_tidy(.x) == .y)
) |>
unlist() |>
# Frequency Table
table() |>
# Sort decreasing
sort(decreasing = TRUE) |>
# Index of largest value is the correct row of the filtered source data
magrittr::extract(1) |>
names() |>
as.integer()
}
# Resolve the row data
rlang::list2(!!src := rlang::eval_tidy(attr(lazy_refs, "src.def"))[row_idx])
# }) |>
}, .options = .furrr_opts) |>
purrr::flatten() %>%
.[!duplicated(names(.))]
}
#
# ~ Validation #4 :: retrace.evs ====
retrace.evs(test.evs$evt_graphs[[1]], test.evs)
install.packages("networkD3")
sample(3, 20, TRUE) %in% c(1,3,5)
sample(3, 20, TRUE) |> (\(x) list(x %in% c(1,3,5), x == c(1,3,5)))()
sample(3, 20, TRUE) |> (\(x) list(x %in% c(1,3,5), x == t(c(1,3,5))))()
sample(3, 20, TRUE) |> (\(x) list(x %in% c(1,3,5), x == c(1,3,5)))()
sample(3, 20, TRUE) |> (\(x) list(x %in% c(1,3,5), x == c(1,3,5)))()
sample(3, 20, TRUE) |> print() %in% c(1,3,5)
sample(8, 20, TRUE) |> print() %in% c(1,3,5)
sample(8, 20, TRUE) |> print() %in% c(1,3,5)
which(sample(8, 20, TRUE) |> print() %in% c(1,3,5))
which(sample(8, 20, TRUE) |> print() %in% c(1,3,5))
index <- rep.int(NA, length(X));
index <- rep.int(NA, length(X));
X <- sample(10, 20, TRUE)
Y <- sample(5, 20, TRUE)
index <- rep.int(NA, length(X));
outer(X, Y, `%in%`)
X <- sample(10, 20, TRUE) |> rlang::set_names()
Y <- sample(5, 20, TRUE) |> rlang::set_names()
index <- rep.int(NA, length(X));
outer(X, Y, `%in%`)
X <- sample(10, 20, TRUE) |> rlang::set_names() |> sort()
Y <- sample(5, 20, TRUE) |> rlang::set_names() |> sort()
index <- rep.int(NA, length(X));
outer(X, Y, `%in%`)
purrr::walk(unique(X), \(i){
out.x <- root[which(X %in% i)];
out.y <- radix[which(X %in% i)];
index[which(root %in% i)] <<- frank(out.y, ties.method = "dense")
})
purrr::walk(unique(X), \(i){
out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- frank(out.y, ties.method = "dense")
})
purrr::walk(unique(X), \(i){
out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(out.y, ties.method = "dense")
})
outer(X, Y, `%in%`)
X <- sample(10, 200, TRUE) |> rlang::set_names() |> sort()
Y <- sample(30, 200, TRUE) |> rlang::set_names() |> sort()
index <- rep.int(NA, length(X));
purrr::walk(unique(X), \(i){
out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(out.y, ties.method = "dense")
})
outer(X, Y, `%in%`)
X <- sample(10, 200, TRUE) |> rlang::set_names()
Y <- sample(30, 200, TRUE) |> rlang::set_names()
index <- rep.int(NA, length(X));
purrr::walk(unique(X), \(i){
out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(out.y, ties.method = "dense")
})
outer(X, Y, `%in%`)
purrr::walk(unique(X), \(i){
# out.x <- X[which(X %in% i)];
# out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
})
index
X <- sample(10, 200, TRUE) |> rlang::set_names()
Y <- sample(30, 200, TRUE) |> rlang::set_names()
index <- rep.int(NA, length(X));
X <- sample(10, 200, TRUE) |> rlang::set_names()
Y <- sample(30, 200, TRUE) |> rlang::set_names()
(index <- rep.int(NA, length(X)));
purrr::walk(unique(X), \(i){
# out.x <- X[which(X %in% i)];
# out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
})
index
rank(X)
data.table::frank(X, ties.method = "dense")
data.table::frank(Y[data.table::frank(X, ties.method = "dense")], ties.method = "dense")
X <- sample(10, 200, TRUE) |> rlang::set_names()
Y <- sample(30, 200, TRUE) |> rlang::set_names()
(index <- rep.int(NA, length(X)));
data.table(x.rank = data.table::frank(X, ties.method = "dense"))[
y.rank := data.table::frank(Y[x.rank], ties.method = "dense")
][]
data.table::data.table(x.rank = data.table::frank(X, ties.method = "dense"))[
y.rank := data.table::frank(Y[x.rank], ties.method = "dense")
][]
library(data.table)
data.table(x.rank = data.table::frank(X, ties.method = "dense"))[
y.rank := data.table::frank(Y[x.rank], ties.method = "dense")
][]
data.table(x.rank = data.table::frank(X, ties.method = "dense"))[
, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")
][]
purrr::walk(unique(X), \(i){
# out.x <- X[which(X %in% i)];
# out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
})
index
data.table(x.rank = data.table::frank(X, ties.method = "dense"))[
, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")
][]
data.table(
x.rank = data.table::frank(X, ties.method = "min")
)[, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")][]
index
purrr::walk(unique(X), \(i){
# out.x <- X[which(X %in% i)];
# out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
print(out.y)
})
purrr::walk(unique(X), \(i){
# out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
print(out.y)
})
purrr::walk(unique(X), \(i){
# out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
# print(out.y)
})
purrr::map(unique(X), \(i){
# out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
# print(out.y)
})
X <- sample(10, 200, TRUE) |> rlang::set_names()
Y <- sample(30, 200, TRUE) |> rlang::set_names()
(index <- rep.int(NA, length(X)));
purrr::map(unique(X), \(i){
# out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
# print(out.y)
}) |> View()
View(index)
print(index)
data.table(
x.rank = data.table::frank(X, ties.method = "min")
)[, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")][]
data.table(
x.rank = data.table::frank(X, ties.method = "min")
)[, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")] |> View()
purrr::map(unique(X), \(i){
# out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
# print(out.y)
}) |> View()
print(index)
data.table(
x.rank = data.table::frank(X, ties.method = "min")
)[, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")] |> View()
source("D:/Imperial Git Repos/event.vectors/SANDBOX.R")
data.table(
X
, x.rank = data.table::frank(X, ties.method = "min")
, Y
)[, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")] |> View()
purrr::map(rlang::set_names(unique(X)), function(i) {[["2"]]
Z <- purrr::map(unique(X) |> rlang::set_names(), \(i){
# out.x <- X[which(X %in% i)];
out.y <- Y[which(X %in% i)];
index[which(X %in% i)] <<- data.table::frank(Y[which(X %in% i)], ties.method = "dense")
# print(out.y)
})
View(Z)
Z[["2"]]
data.table(
X
, x.rank = data.table::frank(X, ties.method = "dense")
, Y
)[, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")] |> View()
print(index)
data.table(
index, X, x.rank = data.table::frank(X, ties.method = "dense"), Y
)[, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")] |>
View()
print(index)
Y[data.table::frank(X, ties.method = "dense")]
Y[data.table::frank(X, ties.method = "dense")] |> unname()
data.table(
index
, X
, x.rank = data.table::frank(X, ties.method = "dense")
, Y
)[, y.rank := data.table::frank(Y[x.rank], ties.method = "dense")] |>
View()
Y[data.table::frank(X, ties.method = "dense")] |> unname()
outer(X,X, \(x, y) which(x %in% y))
outer(X, unique() |> rlang::set_names(), \(x, y) which(y %in% x))
outer(X, unique(X) |> rlang::set_names(), \(x, y) which(y %in% x))
outer(unique(X) |> rlang::set_names(), X, \(x, y) which(x %in% y))
outer(X, unique(X) |> rlang::set_names(), \(x, y) which(y == x))
outer(X, unique(X) |> rlang::set_names(), \(x, y) x == y)
outer(X, unique(X) |> rlang::set_names(), \(x, y) x == y) |> which(arr.ind = TRUE)
outer(X, unique(X) |> rlang::set_names(), \(x, y) x == y) |> print() |> which(arr.ind = TRUE)
outer(X, unique(X) |> rlang::set_names(), \(x, y) x == y) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table()
outer(X, unique(X) |> rlang::set_names(), \(x, y) x == y) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() %>%
.[, list(cbind(row)), by = col]
outer(X, unique(X) |> rlang::set_names(), \(x, y) x == y) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(cbind(row)), by = col])()
outer(X, unique(X) |> rlang::set_names(), \(x, y) x == y) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(as.list(row)), by = col])()
outer(X, unique(X) |> rlang::set_names(), \(x, y) x == y) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(row)), by = col])()
outer(X, unique(X) |> rlang::set_names(), \(x, y) x %in% y) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(row)), by = col])()
outer(X, unique(X) |> rlang::set_names(), \(x, y) y == x) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(row)), by = col])()
outer(X, unique(X) |> rlang::set_names(), \(x, y) y == x) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(row)), by = col])() |>
View()
outer(X, unique(X) |> rlang::set_names(), \(x, y) y == x) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(Y[row])), by = col])() |>
View()
outer(X, unique(X) |> rlang::set_names(), \(x, y) y == x) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(Y[col])), by = row])() |>
View()
outer(X, unique(X) |> rlang::set_names(), \(x, y) y == x) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(Y[row])), by = col])() |>
View()
outer(X, unique(X) |> rlang::set_names(), \(x, y) y == x) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(row)), by = col])() |>
View()
outer(X, unique(X) |> rlang::set_names(), \(x, y) y == x) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(Y[row])), by = col])() |>
View()
Z2 <- outer(X, unique(X) |> rlang::set_names(), \(x, y) y == x) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(Y[row])), by = col])()
View(Z2)
Z2[2,]
Z2[2, V1]
Z2 <- outer(X, unique(X) |> rlang::set_names(), \(x, y) y == x) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(unname(Y)[row])), by = col])()
Z2[2, V1]
Z$`2`
Z2 <- outer(X, unique(X) |> rlang::set_names(), \(x, y) x == y) |>
print() |>
which(arr.ind = TRUE) |>
as.data.table() |>
(\(x) x[, list(list(unname(Y)[row])), by = col])()
View(Z2)
Z$`2`; Z2[2, V1]
Z$`2`; Z2[2, unname(Y)[V1]]
Z$`2`; Z2[2, unname(Y)[V1[[1]]]]
