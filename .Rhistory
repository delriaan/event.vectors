event.vectors::signal_processor(cl_size = 8, nfolds = 5, .debug = !TRUE);
tuned_timeout_islands <- event.vectors::continuity(
data = obs_data
, map_fields = c(join_key, src)
, time_fields = c(date.start, date.end)
, boundary_name = episode
, timeout = !!tuned_timeout@best_k
, show.all = TRUE
);
(\(prescr, tuned){
compare_data <<- prescr[tuned, on = c("join_key", "rec_idx")
, `:=`(tuned_timeout_island = tuned_timeout_island)
, by = .EACHI
][
order(join_key, src, prescr_timeout_island + tuned_timeout_island)
][
, RMS_island_dev := book.of.utilities::calc.rms(as.numeric(prescr_timeout_island) - as.numeric(tuned_timeout_island))
, by = .(join_key, src)
][
, rel_RMS_island_dev := book.of.utilities::ratio(RMS_island_dev, type = "cumulative", d = 4)
, by = .(join_key, src)
][
, MI := table(prescr_timeout_island, tuned_timeout_island) |> mi.empirical(unit = "log2")
, by = .(join_key, src)
]
})(
prescribed_timeout_islands[(GAP > 0), .(join_key, src, rec_idx, prescr_timeout_island = ISLAND, GAP)]
, tuned_timeout_islands[(GAP > 0), .(join_key, src, rec_idx, tuned_timeout_island = ISLAND)]
);
tuned_timeout@plot |>
plotly_layout(
width = 720, margin = list(b = -10)
, paper_bgcolor = "#DDDDDD", plot_bgcolor = "#FEEEFF"
)
compare_data |>
modify_at(c("prescr_timeout_island", "tuned_timeout_island"), as.numeric) |>
plot_ly(
x = ~prescr_timeout_island
, y = ~tuned_timeout_island
, z = ~RMS_island_dev * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = "cumulative", a = TRUE, d = 4)
, hoverinfo = "text"
, hovertext = ~glue::glue("Prescribed timeout (10): Island = {prescr_timeout_island}<br>Tuned timeout ({tuned_timeout@best_k}): Island = {tuned_timeout_island}<br>Likelihood deviation: {RMS_island_dev * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = \"cumulative\", a = TRUE, d = 4) |> round(4)}")
, type = "contour"
, width = 720
, height = 640
) |>
plotly::config(mathjax = "cdn") |>
plotly::colorbar(title = "Density of <br>Island Deviation<sup>RMS</sup>") |>
plotly::hide_colorbar() |>
plotly_layout(
title = TeX("\\text{Tuned vs. Prescribed Timeout} \\\\ \\text{Likelihood RMS Deviation (height)}")
, xaxis = list(title = list(text = TeX("\\text{Island: Prescribed Timeout (t = 10)}")))
, yaxis = list(title = list(text = TeX(glue::glue("\\text{{Island: Tuned Timeout (t = {tuned_timeout@best_k})}}"))))
, margin = list(t = -5, b = -5)
, paper_bgcolor = "#CCCCCC"
) |>
widgetframe::frameableWidget()
compare_data |>
modify_at(c("prescr_timeout_island", "tuned_timeout_island"), as.numeric) |>
plot_ly(
x = ~prescr_timeout_island
, y = ~tuned_timeout_island
, z = ~MI * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = "cumulative", a = TRUE, d = 4)
, hoverinfo = "text"
, hovertext = ~glue::glue("Prescribed timeout (10): Island = {prescr_timeout_island}<br>Tuned timeout ({tuned_timeout@best_k}): Island = {tuned_timeout_island}<br>Likelihood Mutual Information: {MI * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = \"cumulative\", a = TRUE, d = 4) |> round(4)}")
, type = "contour"
, width = 720
, height = 640
) |>
plotly::config(mathjax = "cdn") |>
plotly::colorbar(title = "Density of <br>Island Deviation<sup>RMS</sup>") |>
plotly::hide_colorbar() |>
plotly_layout(
title = TeX("\\text{Tuned vs. Prescribed Timeout} \\\\ \\text{Likelihood Mutual Information (height)}")
, xaxis = list(title = list(text = TeX("\\text{Island: Prescribed Timeout (t = 10)}")))
, yaxis = list(title = list(text = TeX(glue::glue("\\text{{Island: Tuned Timeout (t = {tuned_timeout@best_k})}}"))))
, margin = list(t = -5, b = -5)
, paper_bgcolor = "#CCCCCC"
) |>
widgetframe::frameableWidget()
tuned_timeout@data
library(event.vectors)
knitr::opts_chunk$set(collapse = TRUE,comment = "#>", echo = FALSE, warning = FALSE, cache = FALSE);
htmltools::tags$style(readLines(Sys.getenv("CSS")) |> paste(collapse = "\n")) |> htmltools::tagList();
htmltools::tags$script(
type = 'text/javascript'
, src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.min.js?config=TeX-AMS-MML_CHTML'
) |> htmltools::tagList();
source(Sys.getenv("L2HTML"));
# ~ pkgdown ----
# usethis::use_pkgdown()
# usethis::use_proprietary_license("Chionesu George")
Sys.setenv(CSS = dir(paste0(getwd(), "/../resources"), pattern = "css$", full.names = TRUE))
Sys.setenv(L2HTML = dir(paste0(getwd(), "/../resources"), pattern = "list2html", full.names = TRUE, recursive = TRUE))
knitr::opts_chunk$set(collapse = TRUE,comment = "#>", echo = FALSE, warning = FALSE, cache = FALSE);
htmltools::tags$style(readLines(Sys.getenv("CSS")) |> paste(collapse = "\n")) |> htmltools::tagList();
htmltools::tags$script(
type = 'text/javascript'
, src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.min.js?config=TeX-AMS-MML_CHTML'
) |> htmltools::tagList();
source(Sys.getenv("L2HTML"));
.req_libs <- list(
github = list(libs = c("book.of.workflow", "book.of.utilities", "architect"))
, cran = list(libs = c("data.table", "purrr", "magrittr", "future", "S7", "htmltools", "spsUtil", "parallelly", "parallel", "plotly", "entropy"), url = "CRAN")
);
.req_libs$github$url <- sapply(.req_libs$github$libs, \(i) sprintf("https://github.com/delriaan/%s", i));
# Verify CRAN libraries
missing_libs <- .req_libs$cran$libs |>
(\(x) x[!x %in% rownames(installed.packages())])();
if (!rlang::is_empty(missing_libs)){
cat(sprintf("Please install package '%s' from CRAN", missing_libs) , sep = "\n");
stop();
}
# Verify GitHub libraries
missing_libs <- .req_libs$github$libs |>
rlang::set_names(.req_libs$github$url) |>
(\(x) x[!x %in% rownames(installed.packages())])();
if (!rlang::is_empty(missing_libs)){
cat(sprintf("Please install package '%s' from GitHub <%s>", missing_libs, names(missing_libs))
, sep = "\n");
stop();
}
spsUtil::quiet(book.of.workflow::load_unloaded(!!!.req_libs$github$libs, !!!.req_libs$cran$libs));
# Load objects
plotly_layout <- function(p, ...){
default_args <- list(
p = p
, plot_bgcolor = "#DDDDDD"
, xaxis = list(showgrid = FALSE)
, yaxis = list(showgrid = FALSE)
);
user_args <- rlang::list2(...);
if (hasName(user_args, "xaxis")){ user_args$xaxis <- purrr::discard_at(user_args$xaxis, "showgrid"); }
if (hasName(user_args, "yaxis")){ user_args$yaxis <- purrr::discard_at(user_args$yaxis, "showgrid"); }
if (hasName(user_args, "plot_bgcolor")){ default_args <- purrr::discard_at(default_args, "plot_bgcolor"); }
do.call(plotly::layout, args = purrr::list_merge(default_args, !!!user_args));
}
make.test_data <- function(j = 5, n = 5, m = 5, o = 1:10, dest = globalenv(), .debug = FALSE){
#' Make Test Data for Validation
#'
#' \code{make.test_data} creates several \code{\link[data.table]{data.table}} objects to be used to validate the package functionality
#' @param j (integer | 5L) The number of unique values for 'k' to generate
#' @param n (integer | 5L) The number of sources to create (maximum of 10)
#' @param m (integer | 5L) The maximum number of columns to generate for each created object (maximum of 15): each column represents an attribute not related to time
#' @param o (integer[] | 1:10) A vector of integers sampled to create end dates from a randomly-generated start date
#' @param dest (environment) The destination environment object
#' @param .debug (logical | \code{FALSE}) When \code{TRUE}, additional debugging items are printed
#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 10, 10, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
o = { ifelse(rlang::has_length(o, 1L)
, yes = 1:10
, no = ifelse(any(o <= 0)
, yes = abs(o)
, no = ifelse(rlang::has_length(o, 2L)
, yes = `:`(o[1], o[2]) |> sort()
, no =  o))
)}
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0")))|>
purrr::map(~{
set.seed(sample(.Random.seed, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(join_key = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(join_key), lambda = sample(o, length(join_key), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(join_key)) > 0.65
] %>%
data.table::setkey(join_key, src, date.start, date.end) %>%
data.table::setcolorder(c("join_key", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
set.seed(sample(100000, 1));
spsUtil::quiet(make.test_data(j = 50, n = 3, m = 5, o = c(5, 20)));
obs_data <- data.table::rbindlist(list(test_data.01, test_data.02, test_data.03), use.names = FALSE)[
, `:=`(Z_1 = sample(letters, .N, TRUE), Z_2 = sample(LETTERS[1:5], .N, TRUE))
] |>
data.table::setkey(join_key, src, date.start);
list2html(.req_libs |> imap(\(x, y){ x$libs })) |> tagList()
dt_options <- list(dom = "rt");
obs_data[, 1:7] |>
head(10) %>%
purrr::modify_at(names(purrr::keep(., is.numeric)), \(i) round(i, 2)) %>%
DT::datatable(
caption = htmltools::h3(style = "color:#555555;" , "Sample of synthesized observation data") |> as.character() |> htmltools::HTML()
, escape = FALSE
, rownames = FALSE
, options = dt_options
) %>%
DT::formatStyle(columns = names(obs_data[, 1:7]), fontSize = '10.5pt', textAlign='center')
# PRESCRIPTED TIMEOUT ====
prescribed_timeout_islands <- event.vectors::continuity(
data = obs_data
, map_fields = c(join_key, src)
, time_fields = c(date.start, date.end)
, boundary_name = episode
, timeout = 10
, show.all = TRUE
);
# TUNED TIMEOUT ====
tuned_timeout <- event.vectors::break_signal(
y = obs_data$date.start
, grp = obs_data[, paste(join_key, src, sep = ":")]
, obs_ctrl = list(min_size = 5L, max_k = 120)
) |>
event.vectors::signal_processor(cl_size = 8, nfolds = 5, .debug = !TRUE);
tuned_timeout_islands <- event.vectors::continuity(
data = obs_data
, map_fields = c(join_key, src)
, time_fields = c(date.start, date.end)
, boundary_name = episode
, timeout = !!tuned_timeout@best_k
, show.all = TRUE
);
(\(prescr, tuned){
compare_data <<- prescr[tuned, on = c("join_key", "rec_idx")
, `:=`(tuned_timeout_island = tuned_timeout_island)
, by = .EACHI
][
order(join_key, src, prescr_timeout_island + tuned_timeout_island)
][
, RMS_island_dev := book.of.utilities::calc.rms(as.numeric(prescr_timeout_island) - as.numeric(tuned_timeout_island))
, by = .(join_key, src)
][
, rel_RMS_island_dev := book.of.utilities::ratio(RMS_island_dev, type = "cumulative", d = 4)
, by = .(join_key, src)
][
, MI := table(prescr_timeout_island, tuned_timeout_island) |> mi.empirical(unit = "log2")
, by = .(join_key, src)
]
})(
prescribed_timeout_islands[(GAP > 0), .(join_key, src, rec_idx, prescr_timeout_island = ISLAND, GAP)]
, tuned_timeout_islands[(GAP > 0), .(join_key, src, rec_idx, tuned_timeout_island = ISLAND)]
);
tuned_timeout@plot |>
plotly_layout(
width = 720, margin = list(b = -10)
, paper_bgcolor = "#DDDDDD", plot_bgcolor = "#FEEEFF"
)
compare_data |>
modify_at(c("prescr_timeout_island", "tuned_timeout_island"), as.numeric) |>
plot_ly(
x = ~prescr_timeout_island
, y = ~tuned_timeout_island
, z = ~RMS_island_dev * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = "cumulative", a = TRUE, d = 4)
, hoverinfo = "text"
, hovertext = ~glue::glue("Prescribed timeout (10): Island = {prescr_timeout_island}<br>Tuned timeout ({tuned_timeout@best_k}): Island = {tuned_timeout_island}<br>Likelihood deviation: {RMS_island_dev * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = \"cumulative\", a = TRUE, d = 4) |> round(4)}")
, type = "contour"
, width = 720
, height = 640
) |>
plotly::config(mathjax = "cdn") |>
plotly::colorbar(title = "Density of <br>Island Deviation<sup>RMS</sup>") |>
plotly::hide_colorbar() |>
plotly_layout(
title = TeX("\\text{Tuned vs. Prescribed Timeout} \\\\ \\text{Likelihood RMS Deviation (height)}")
, xaxis = list(title = list(text = TeX("\\text{Island: Prescribed Timeout (t = 10)}")))
, yaxis = list(title = list(text = TeX(glue::glue("\\text{{Island: Tuned Timeout (t = {tuned_timeout@best_k})}}"))))
, margin = list(t = -5, b = -5)
, paper_bgcolor = "#CCCCCC"
) |>
widgetframe::frameableWidget()
compare_data |>
modify_at(c("prescr_timeout_island", "tuned_timeout_island"), as.numeric) |>
plot_ly(
x = ~prescr_timeout_island
, y = ~tuned_timeout_island
, z = ~MI * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = "cumulative", a = TRUE, d = 4)
, hoverinfo = "text"
, hovertext = ~glue::glue("Prescribed timeout (10): Island = {prescr_timeout_island}<br>Tuned timeout ({tuned_timeout@best_k}): Island = {tuned_timeout_island}<br>Likelihood Mutual Information: {MI * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = \"cumulative\", a = TRUE, d = 4) |> round(4)}")
, type = "contour"
, width = 720
, height = 640
) |>
plotly::config(mathjax = "cdn") |>
plotly::colorbar(title = "Density of <br>Island Deviation<sup>RMS</sup>") |>
plotly::hide_colorbar() |>
plotly_layout(
title = TeX("\\text{Tuned vs. Prescribed Timeout} \\\\ \\text{Likelihood Mutual Information (height)}")
, xaxis = list(title = list(text = TeX("\\text{Island: Prescribed Timeout (t = 10)}")))
, yaxis = list(title = list(text = TeX(glue::glue("\\text{{Island: Tuned Timeout (t = {tuned_timeout@best_k})}}"))))
, margin = list(t = -5, b = -5)
, paper_bgcolor = "#CCCCCC"
) |>
widgetframe::frameableWidget()
tuned_timeout@best_k
tuned_timeout@alt_k
library(event.vectors)
# ~ pkgdown ----
# usethis::use_pkgdown()
# usethis::use_proprietary_license("Chionesu George")
Sys.setenv(CSS = dir(paste0(getwd(), "/../resources"), pattern = "css$", full.names = TRUE))
Sys.setenv(L2HTML = dir(paste0(getwd(), "/../resources"), pattern = "list2html", full.names = TRUE, recursive = TRUE))
knitr::opts_chunk$set(collapse = TRUE,comment = "#>", echo = FALSE, warning = FALSE, cache = FALSE);
htmltools::tags$style(readLines(Sys.getenv("CSS")) |> paste(collapse = "\n")) |> htmltools::tagList();
htmltools::tags$script(
type = 'text/javascript'
, src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.min.js?config=TeX-AMS-MML_CHTML'
) |> htmltools::tagList();
source(Sys.getenv("L2HTML"));
.req_libs <- list(
github = list(libs = c("book.of.workflow", "book.of.utilities", "architect"))
, cran = list(libs = c("data.table", "purrr", "magrittr", "future", "S7", "htmltools", "spsUtil", "parallelly", "parallel", "plotly", "entropy"), url = "CRAN")
);
.req_libs$github$url <- sapply(.req_libs$github$libs, \(i) sprintf("https://github.com/delriaan/%s", i));
# Verify CRAN libraries
missing_libs <- .req_libs$cran$libs |>
(\(x) x[!x %in% rownames(installed.packages())])();
if (!rlang::is_empty(missing_libs)){
cat(sprintf("Please install package '%s' from CRAN", missing_libs) , sep = "\n");
stop();
}
# Verify GitHub libraries
missing_libs <- .req_libs$github$libs |>
rlang::set_names(.req_libs$github$url) |>
(\(x) x[!x %in% rownames(installed.packages())])();
if (!rlang::is_empty(missing_libs)){
cat(sprintf("Please install package '%s' from GitHub <%s>", missing_libs, names(missing_libs))
, sep = "\n");
stop();
}
spsUtil::quiet(book.of.workflow::load_unloaded(!!!.req_libs$github$libs, !!!.req_libs$cran$libs));
# Load objects
plotly_layout <- function(p, ...){
default_args <- list(
p = p
, plot_bgcolor = "#DDDDDD"
, xaxis = list(showgrid = FALSE)
, yaxis = list(showgrid = FALSE)
);
user_args <- rlang::list2(...);
if (hasName(user_args, "xaxis")){ user_args$xaxis <- purrr::discard_at(user_args$xaxis, "showgrid"); }
if (hasName(user_args, "yaxis")){ user_args$yaxis <- purrr::discard_at(user_args$yaxis, "showgrid"); }
if (hasName(user_args, "plot_bgcolor")){ default_args <- purrr::discard_at(default_args, "plot_bgcolor"); }
do.call(plotly::layout, args = purrr::list_merge(default_args, !!!user_args));
}
make.test_data <- function(j = 5, n = 5, m = 5, o = 1:10, dest = globalenv(), .debug = FALSE){
#' Make Test Data for Validation
#'
#' \code{make.test_data} creates several \code{\link[data.table]{data.table}} objects to be used to validate the package functionality
#' @param j (integer | 5L) The number of unique values for 'k' to generate
#' @param n (integer | 5L) The number of sources to create (maximum of 10)
#' @param m (integer | 5L) The maximum number of columns to generate for each created object (maximum of 15): each column represents an attribute not related to time
#' @param o (integer[] | 1:10) A vector of integers sampled to create end dates from a randomly-generated start date
#' @param dest (environment) The destination environment object
#' @param .debug (logical | \code{FALSE}) When \code{TRUE}, additional debugging items are printed
#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 10, 10, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
o = { ifelse(rlang::has_length(o, 1L)
, yes = 1:10
, no = ifelse(any(o <= 0)
, yes = abs(o)
, no = ifelse(rlang::has_length(o, 2L)
, yes = `:`(o[1], o[2]) |> sort()
, no =  o))
)}
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0")))|>
purrr::map(~{
set.seed(sample(.Random.seed, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(join_key = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(join_key), lambda = sample(o, length(join_key), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(join_key)) > 0.65
] %>%
data.table::setkey(join_key, src, date.start, date.end) %>%
data.table::setcolorder(c("join_key", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
set.seed(sample(100000, 1));
spsUtil::quiet(make.test_data(j = 50, n = 3, m = 5, o = c(5, 20)));
obs_data <- data.table::rbindlist(list(test_data.01, test_data.02, test_data.03), use.names = FALSE)[
, `:=`(Z_1 = sample(letters, .N, TRUE), Z_2 = sample(LETTERS[1:5], .N, TRUE))
] |>
data.table::setkey(join_key, src, date.start);
list2html(.req_libs |> imap(\(x, y){ x$libs })) |> tagList()
dt_options <- list(dom = "rt");
obs_data[, 1:7] |>
head(10) %>%
purrr::modify_at(names(purrr::keep(., is.numeric)), \(i) round(i, 2)) %>%
DT::datatable(
caption = htmltools::h3(style = "color:#555555;" , "Sample of synthesized observation data") |> as.character() |> htmltools::HTML()
, escape = FALSE
, rownames = FALSE
, options = dt_options
) %>%
DT::formatStyle(columns = names(obs_data[, 1:7]), fontSize = '10.5pt', textAlign='center')
# PRESCRIPTED TIMEOUT ====
prescribed_timeout_islands <- event.vectors::continuity(
data = obs_data
, map_fields = c(join_key, src)
, time_fields = c(date.start, date.end)
, boundary_name = episode
, timeout = 10
, show.all = TRUE
);
# TUNED TIMEOUT ====
tuned_timeout <- event.vectors::break_signal(
y = obs_data$date.start
, grp = obs_data[, paste(join_key, src, sep = ":")]
, obs_ctrl = list(min_size = 5L, max_k = 120)
) |>
event.vectors::signal_processor(cl_size = 8, nfolds = 5, .debug = !TRUE);
tuned_timeout_islands <- event.vectors::continuity(
data = obs_data
, map_fields = c(join_key, src)
, time_fields = c(date.start, date.end)
, boundary_name = episode
, timeout = !!tuned_timeout@best_k
, show.all = TRUE
);
(\(prescr, tuned){
compare_data <<- prescr[tuned, on = c("join_key", "rec_idx")
, `:=`(tuned_timeout_island = tuned_timeout_island)
, by = .EACHI
][
order(join_key, src, prescr_timeout_island + tuned_timeout_island)
][
, RMS_island_dev := book.of.utilities::calc.rms(as.numeric(prescr_timeout_island) - as.numeric(tuned_timeout_island))
, by = .(join_key, src)
][
, rel_RMS_island_dev := book.of.utilities::ratio(RMS_island_dev, type = "cumulative", d = 4)
, by = .(join_key, src)
][
, MI := table(prescr_timeout_island, tuned_timeout_island) |> mi.empirical(unit = "log2")
, by = .(join_key, src)
]
})(
prescribed_timeout_islands[(GAP > 0), .(join_key, src, rec_idx, prescr_timeout_island = ISLAND, GAP)]
, tuned_timeout_islands[(GAP > 0), .(join_key, src, rec_idx, tuned_timeout_island = ISLAND)]
);
tuned_timeout@plot |>
plotly_layout(
width = 720, margin = list(b = -10)
, paper_bgcolor = "#DDDDDD", plot_bgcolor = "#FEEEFF"
)
compare_data |>
modify_at(c("prescr_timeout_island", "tuned_timeout_island"), as.numeric) |>
plot_ly(
x = ~prescr_timeout_island
, y = ~tuned_timeout_island
, z = ~RMS_island_dev * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = "cumulative", a = TRUE, d = 4)
, hoverinfo = "text"
, hovertext = ~glue::glue("Prescribed timeout (10): Island = {prescr_timeout_island}<br>Tuned timeout ({tuned_timeout@best_k}): Island = {tuned_timeout_island}<br>Likelihood deviation: {RMS_island_dev * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = \"cumulative\", a = TRUE, d = 4) |> round(4)}")
, type = "contour"
, width = 720
, height = 640
) |>
plotly::config(mathjax = "cdn") |>
plotly::colorbar(title = "Density of <br>Island Deviation<sup>RMS</sup>") |>
plotly::hide_colorbar() |>
plotly_layout(
title = TeX("\\text{Tuned vs. Prescribed Timeout} \\\\ \\text{Likelihood RMS Deviation (height)}")
, xaxis = list(title = list(text = TeX("\\text{Island: Prescribed Timeout (t = 10)}")))
, yaxis = list(title = list(text = TeX(glue::glue("\\text{{Island: Tuned Timeout (t = {tuned_timeout@best_k})}}"))))
, margin = list(t = -5, b = -5)
, paper_bgcolor = "#CCCCCC"
) |>
widgetframe::frameableWidget()
compare_data |>
modify_at(c("prescr_timeout_island", "tuned_timeout_island"), as.numeric) |>
plot_ly(
x = ~prescr_timeout_island
, y = ~tuned_timeout_island
, z = ~MI * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = "cumulative", a = TRUE, d = 4)
, hoverinfo = "text"
, hovertext = ~glue::glue("Prescribed timeout (10): Island = {prescr_timeout_island}<br>Tuned timeout ({tuned_timeout@best_k}): Island = {tuned_timeout_island}<br>Likelihood Mutual Information: {MI * book.of.utilities::ratio(prescr_timeout_island * tuned_timeout_island, type = \"cumulative\", a = TRUE, d = 4) |> round(4)}")
, type = "contour"
, width = 720
, height = 640
) |>
plotly::config(mathjax = "cdn") |>
plotly::colorbar(title = "Density of <br>Island Deviation<sup>RMS</sup>") |>
plotly::hide_colorbar() |>
plotly_layout(
title = TeX("\\text{Tuned vs. Prescribed Timeout} \\\\ \\text{Likelihood Mutual Information (height)}")
, xaxis = list(title = list(text = TeX("\\text{Island: Prescribed Timeout (t = 10)}")))
, yaxis = list(title = list(text = TeX(glue::glue("\\text{{Island: Tuned Timeout (t = {tuned_timeout@best_k})}}"))))
, margin = list(t = -5, b = -5)
, paper_bgcolor = "#CCCCCC"
) |>
widgetframe::frameableWidget()
tuned_timeout
pkgdown::build_site(pkg = "pkg", examples = FALSE, override = list(destination = "../docs"))
