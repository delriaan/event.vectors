inspect <- as.matrix(trans_matrix);
walk(purrr::set_names(2:100), ~{
inspect <<- rbind(inspect, {
(inspect[nrow(inspect), ] %*% trans_matrix) %>%
.[1, order(colnames(.))]
})
})
View(inspect)
inspect[, order(colnames(inspect))]
inspect <- as.matrix(trans_matrix);
inspect <- as.matrix(trans_matrix[1, ]);
inspect <- as.matrix(trans_matrix[1, ]);
inspect <- as.matrix(trans_matrix[1, ]);
trans_matrix
inspect <- trans_matrix[1, ]
inspect <- trans_matrix["Src1", ]
inspect <- trans_matrix["Src1", ] %>% as.matrix()
inspect <- trans_matrix["Src1", ] %>% t() %>% as.matrix()
View(inspect)
walk(purrr::set_names(2:100), ~{
inspect <<- rbind(inspect, {
(inspect[nrow(inspect), ] %*% trans_matrix)
})
})
inspect[, order(colnames(inspect))]
plot_ly(
x =colnames(inspect[, order(colnames(inspect))])
, y = ~2:nrow(inspect)
, z = rowDiffs(inspect[, order(colnames(inspect))])
, type = "contour"
)
plot_ly(
x =colnames(inspect[, order(colnames(inspect))])
, y = ~2:nrow(inspect)
, z = colDiffs(inspect[, order(colnames(inspect))])
, type = "contour"
)
rowDiffs(inspect[, order(colnames(inspect))])
inspect
inspect[1:10, ]
inspect[1:10, ] %>% rowDiffs()
inspect[1:10, ] %>% colDiffs()
inspect[1:10, ] %>% print() %>% colDiffs()
plot_ly(
x =colnames(inspect[, order(colnames(inspect))])
, y = ~2:nrow(inspect)
, z = colDiffs(inspect[, order(colnames(inspect))])
, type = "contour"
)
plot_ly(
x =colnames(inspect[, order(colnames(inspect))])
, y = ~2:nrow(inspect)
, z = colDiffs(inspect[, order(colnames(inspect))]) %>% round(4)
, type = "contour"
)
plot_ly(
x =colnames(inspect[, order(colnames(inspect))])
, y = ~2:nrow(inspect)
, z = colDiffs(inspect[, order(colnames(inspect))]) %>% round(6)
, type = "contour"
)
walk(purrr::set_names(2:30), ~{
inspect <<- rbind(inspect, {
(inspect[nrow(inspect), ] %*% trans_matrix)
})
})
plot_ly(
x =colnames(inspect[, order(colnames(inspect))])
, y = ~2:nrow(inspect)
, z = colDiffs(inspect[, order(colnames(inspect))]) %>% round(6)
, type = "contour"
)
inspect <- trans_matrix["Src1", ] %>% t() %>% as.matrix()
walk(purrr::set_names(2:30), ~{
inspect <<- rbind(inspect, {
(inspect[nrow(inspect), ] %*% trans_matrix)
})
})
plot_ly(
x =colnames(inspect[, order(colnames(inspect))])
, y = ~2:nrow(inspect)
, z = colDiffs(inspect[, order(colnames(inspect))]) %>% round(6)
, type = "contour"
)
inspect <- trans_matrix["Src1", ] %>% t() %>% as.matrix()
walk(purrr::set_names(2:30), ~{
inspect <<- rbind(inspect, {
(inspect[nrow(inspect), ] %*% trans_matrix)
})
})
plot_ly(
x =colnames(inspect[, order(colnames(inspect))])
, y = ~2:nrow(inspect)
, z = colDiffs(inspect[, order(colnames(inspect))]) %>% round(6)
, type = "contour"
)
inspect <- trans_matrix["Src1", ] %>% t() %>% as.matrix()
walk(purrr::set_names(2:30), ~{
inspect <<- rbind(inspect, {
(inspect[nrow(inspect), ] %*% trans_matrix)
})
})
inspect %<>% .[, order(colnames(.))]
plot_ly(
x =colnames(inspect)
, y = ~2:nrow(inspect)
, z = colDiffs(inspect) %>% round(6)
, type = "contour"
)
plot_ly(
x =colnames(inspect)
, y = ~2:nrow(inspect)
, z = inspect[-1, ] * (colDiffs(inspect) %>% round(4) != 0)
, type = "contour"
)
plot_ly(
x =colnames(inspect)
, y = ~2:nrow(inspect)
, z = inspect[-1, ] * all(colDiffs(inspect) %>% round(4) != 0)
, type = "contour"
)
plot_ly(
x =colnames(inspect)
, y = ~2:nrow(inspect)
, z = inspect[-1, ] * (colDiffs(inspect) %>% round(4) != 0)
, type = "contour"
)
inspect <- trans_matrix["Src1", ] %>% t() %>% as.matrix()
walk(purrr::set_names(1:30), ~{
inspect <<- rbind(inspect, {
(inspect[nrow(inspect), ] %*% trans_matrix)
})
})
inspect %<>% .[, order(colnames(.))]
plot_ly(
x =colnames(inspect)
, y = ~1:nrow(inspect)
, z = inspect[-1, ] * (colDiffs(inspect) %>% round(4) != 0)
, type = "contour"
)
inspect <- trans_matrix["Src1", ] %>% t() %>% as.matrix()
walk(purrr::set_names(1:30), ~{
inspect <<- rbind(inspect, (inspect[nrow(inspect), ] %*% trans_matrix))
})
inspect <- trans_matrix["Src2", ] %>% t() %>% as.matrix()
walk(purrr::set_names(1:30), ~{
inspect <<- rbind(inspect, (inspect[nrow(inspect), ] %*% trans_matrix))
})
inspect %<>% .[, order(colnames(.))]
plot_ly(
x =colnames(inspect)
, y = ~1:nrow(inspect)
, z = inspect[-1, ] * (colDiffs(inspect) %>% round(4) != 0)
, type = "contour"
)
inspect <- trans_matrix["Src3", ] %>% t() %>% as.matrix()
walk(purrr::set_names(1:30), ~{
inspect <<- rbind(inspect, (inspect[nrow(inspect), ] %*% trans_matrix))
})
inspect %<>% .[, order(colnames(.))]
plot_ly(
x =colnames(inspect)
, y = ~1:nrow(inspect)
, z = inspect[-1, ] * (colDiffs(inspect) %>% round(4) != 0)
, type = "contour"
)
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
map(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
)
})
subplot(markov_viz, nrows = length(markov_viz))
rlang::inject(subplot(!!!markov_viz, nrows = length(markov_viz)))
markov_viz$Src1
split(trans_matrix, f = rownames(trans_matrix))
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
map(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
)
})
markov_viz$Src1
markov_viz
split(trans_matrix, f = rownames(trans_matrix))
rm(f, from, to)
rm(inspect)
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
map(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
) %>%
plotly::layout(title = .y) %T>% print()
})
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
map(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
) %>% print()
# plotly::layout(title = .y)
})
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
map(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))] %>% print()
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
) %>%
plotly::layout(title = .y)
})
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
map(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
print(out)
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
) %>%
plotly::layout(title = .y)
})
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
map(~{
cat(.y)
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
print(out)
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
) %>%
plotly::layout(title = .y)
})
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
imap(~{
cat(.y)
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
) %>%
plotly::layout(title = .y)
})
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
imap(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
) %>%
plotly::layout(title = .y)
})
rlang::inject(subplot(!!!markov_viz, nrows = length(markov_viz)))
rlang::inject(subplot(!!!markov_viz, nrows = 3))
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
imap(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = colnames(out)
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
, name = .y
) %>%
plotly::layout(title = .y)
})
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
imap(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = sprintf("From %s: To ", .y, colnames(out))
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
, name = .y
) %>%
plotly::layout(title = .y)
})
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
imap(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = sprintf("From %s: To %s", .y, colnames(out))
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
, name = .y
) %>%
plotly::layout(title = .y)
})
rlang::inject(subplot(!!!markov_viz, nrows = 3, ))
markov_viz <- split(trans_matrix, f = rownames(trans_matrix)) %>%
imap(~{
out = t(.x) %>% as.matrix()
walk(purrr::set_names(1:30), ~{
out <<- rbind(out, (out[nrow(out), ] %*% trans_matrix))
})
out %<>% .[, order(colnames(.))]
plot_ly(
x = sprintf("From %s: To %s", .y, colnames(out))
, y = ~1:nrow(out)
, z = out[-1, ] * (colDiffs(out) %>% round(4) != 0)
, type = "contour"
, name = .y
) %>%
plotly::layout(title = .y)
})
markov_viz
rlang::inject(subplot(!!!markov_viz, nrows = 3))
rlang::inject(subplot(!!!markov_viz, nrows = 3)) %>%
plotly::layout(title = "Steady-State vs Initial Source")
rlang::inject(subplot(!!!markov_viz, nrows = 3)) %>%
plotly::layout(
title = "Steady-State vs Initial Source"
, margin = list(t = -.5)
)
library(EVSpace)
list(8, 2)
list(8, 2) |> order()
list(8, 2) |> as.vector() %>% .[order(.)]
(function(i){ i[as.vector(i) |> order()] })(list(8, 2))
(function(i){ i[unlist(i) |> order()] })(list(8, 2))
list(8, 2) |> sort)
list(8, 2) |> sort
list(8, 2) |> sort()
list(NULL, 3 6)
list(NULL, 3, 6)
as.complex(NA)
library(EVSpace)
function(self, ..., time.control = list(-Inf, Inf), graph.control = NULL, furrr_opts = furrr::furrr_options(scheduling = Inf, seed = TRUE), omit.na = FALSE, chatty = FALSE){
#' Create the EVSpace Universe
#'
#' \code{make.evs_universe} supplies values to two class fields: \code{q_graph} and \code{space}, the latter being created from the former.
#'
#' @param evs An \code{EVSpace} object
#' @param ... (\code{\link[rlang]{dots_list}}) Logical expression that retain graph edges meeting the conditions
#' @param time.control A 2-element list containing the minimum and maximum values allowed for total temporal span between two events
#' @param graph.control An expression list containing \code{\link[igraph]{igraph-package}} calls to manipulate the internally-created graph in the order provided.  Use symbol \code{g} to generically denote the graph
#' @param furrr_opts \code{\link[furrr]{furrr_options}} defaulted as \code{scheduling = Inf} and \code{seed = TRUE}: internal globals are also set and will be appended to values provided here
#' @param omit.na (logical | \code{FALSE}) \code{TRUE} removes rows from class member \code{space} that have \code{NA} values
#' @param chatty (logical | \code{FALSE}) Verbosity flag
#'
#' @return Invisibly, the original object augmented with new member \code{space}
#'
#' @section Notes:
#' \itemize{
#' \item{Class member \code{$space} should have as many rows as the sum of all edge counts for graphs in \code{$q_graph}}
#' \item{The graphs in class member \code{$evt_graphs} are \code{\link[visNetwork]{visIgraph}}-ready}
#' \item{Parallelism is internally supported via package \code{furrr}: the user is responsible for setting the appropriate \code{\link[future]{plan}}}
#' }
#' @export
force(self);
edge.filter <- if (...length() > 0){
str2lang(rlang::enquos(..., .named = FALSE, .ignore_empty = "all") |>
purrr::map_chr(~{ rlang::get_expr(.x) |> deparse() |> sprintf(fmt = "(%s)") }) |>
paste(collapse = " & "))
} else { TRUE }
# :: Create self$space from self$q_graph via calls to 'cross.time()'
furrr_opts$globals <- furrr_opts$globals |> c(".evs_cache", "graph.control", ".vnames", ".graphs", "self", "cross.time") |> unique();
.src_mix <- self$.__enclos_env__$private$q_table |> as.list() |> data.table::transpose() %>% purrr::set_names(purrr::map_chr(., paste, collapse = " -> "));
# Retrieve the essential columns from sources and create a compact intermediate  data structure
.tmp_space <- self$config$src.names |>
purrr::map(~eval(str2lang(.x), envir = globalenv()) %>% .[, .(jk, start_idx, end_idx, src)]) |>
data.table::rbindlist() |>
data.table::setkey(jk, start_idx, end_idx);
# `make.event_key` is used to create sequential unique identifiers for events sources and time-markers
make.event_key <- purrr::as_mapper(~{
root = .x
radix = .y
index = rep.int(NA, length(root));
# Populate 'index' based on unique values of 'root'
purrr::walk(unique(root), ~{
out.x = root[which(root %in% .x)]
out.y = radix[which(root %in% .x)];
index[which(root %in% .x)] <<- data.table::frank(out.y, ties.method = "dense")
})
index
})
# Use optimization from 'data.table' to create `self$space`
self$space <- { .tmp_space[
,{f_data <- purrr::map(.src_mix, ~{
.SD[(src %in% .x[1]), .(f_start_idx = start_idx, f_end_idx = end_idx, f_src = src)] %>% purrr::compact()
}) |> data.table::rbindlist()
t_data <- purrr::map(.src_mix, ~{
.SD[(src %in% .x[2]), .(t_start_idx = start_idx, t_end_idx = end_idx, t_src = src)] %>% purrr::compact()
}) |> data.table::rbindlist()
if (rlang::is_empty(f_data) | rlang::is_empty(t_data)){
f_data <- data.table(f_start_idx = NA, f_end_idx = NA, f_src = NA)
t_data <- data.table(t_start_idx = NA, t_end_idx = NA, t_src = NA)
}
# Output data
c(f_data, t_data)
}
, by = jk
][
!is.na(f_src)
, unique(.SD) %$% { # Call `cross.time()`
c(cross.time(s0 = f_start_idx, s1 = t_start_idx, e0 = f_end_idx, e1 = t_end_idx, control = time.control)
, data.table::data.table(
from.coord				= purrr::map2_chr(f_start_idx, f_end_idx, paste, sep = ":")
, to.coord  			= purrr::map2_chr(t_start_idx, t_end_idx, paste, sep = ":")
, from_timeframe	= purrr::map2(f_start_idx, f_end_idx, lubridate::interval)
, to_timeframe  	= purrr::map2(t_start_idx, t_end_idx, lubridate::interval)
)
}
, by = .(jk, f_src, t_src)
][
# Enforce row filter rules before proceeding
!is.na(epsilon) & eval(edge.filter)
][
# Impute sequencing on event sources: this has a direct impact when creating distinct vertex names during subsequent graph creation
, c("f_src", "t_src") := list(paste(f_src, make.event_key(f_src, from.coord), sep = ":")
, paste(t_src, make.event_key(t_src, to.coord), sep = ":"))
, by  = .(jk)
][, src.pair := sprintf("%s -> %s", f_src, t_src)] %>%
data.table::setnames(c("f_src", "t_src"), c("from.src", "to.src"))
}
if (omit.na){
logi_vec = apply(X = self$space, MARGIN = 1, FUN = function(i){ !any(is.na(i)) })
self$space %<>% .[(logi_vec)]
}
# :: Create `self$evt_graphs` from `self$space`
self$evt_graphs <- self$space |> split(by = "jk") |> purrr::map(~igraph::graph_from_data_frame(data.table::setcolorder(.x, c("from.src", "to.src"))));
.graphs <- self$evt_graphs;
# :: Finalize
message(sprintf("[%s] ... finalizing", Sys.time()));
self$evt_graphs <- furrr::future_map(self$evt_graphs, ~{
g = .x;
if (!rlang::is_empty(graph.control)){ for (i in graph.control){ eval(i) } }
g;
}, .options = furrr_opts) |> purrr::compact();
attr(self$space, "contexts") <- self$config$contexts;
message(sprintf("[%s] The vector space is ready for analysis", Sys.time()));
invisible(self);
}
detach("package:EVSpace", unload = TRUE)
remove.packages("EVSpace")
library(EVSpace)
detach("package:EVSpace", unload = TRUE)
library(EVSpace)
