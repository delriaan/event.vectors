, from_timeframe = purrr::map2(f_start_idx, f_end_idx, lubridate::interval)
, to_timeframe   = purrr::map2(t_start_idx, t_end_idx, lubridate::interval)
, from.src = f_src
, to.src = t_src
)
, by = .(jk, src.pair = sprintf("%s -> %s", f_src, t_src))
][!is.na(epsilon) & eval(edge.filter)]
}
library(EVSpace)
# ~Initialization ====
# library(EVSpace);
library(purrr)
library(tictoc);
library(future);
plan(tweak(multisession, workers = 5))
#
make.test_data <- function(j = 5, n = 5, m = 5, dest = globalenv(), .debug = FALSE){
#' Make Test Data for Validation
#'
#' \code{make.test_data} creates several \code{\link[data.table]{data.table}} objects to be used to validate the package functionality
#' @param j (integer | 5L) The number of unique values for 'k' to generate
#' @param n (integer | 5L) The number of sources to create (maximum of 5)
#' @param m (integer | 5L) The maximum number of columns to generate for each created object (maximum of 15): each column represents an attribute not related to time
#' @param dest (environment) The destination environment object
#' @param .debug (logical | \code{FALSE}) When \code{TRUE}, additional debugging items are printed
#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 5, 5, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0"))) %>%
purrr::map(~{
set.seed(sample(1:10000, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(jk = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(jk), lambda = sample(1:100, length(jk), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(jk)) > 0.65
] %>%
data.table::setkey(jk, src, date.start, date.end) %>%
data.table::setcolorder(c("jk", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
BLAH <- new.env();
make.test_data(j = 5, n = 5, m = 5, dest = BLAH, .debug = !TRUE);
set.seed(sample(100000, 1));
# ~ Create EVSpace object from test data
tic.clear(); tic.clearlog();
# ~ Validation #1 ====
tic("EVSpace Validation Object");
#
test.evs <- event.vector.space$new();
test.evs$
configure(
src.names			= paste0("BLAH$", ls(pattern = "^test_data", envir = BLAH))
, contexts		= paste0("Src", 1:length(ls(pattern = "^test_data", envir = BLAH)))
, map.fields	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~c("jk", "date.start", "date.end"))
, row.filters	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~rlang::expr(1==1))
, src.mix 		= "combn"
, chatty			= TRUE
, exclude.mix = { c(
evs_exclude.blender("Data.6", c("Data.4", "Data.7"))
, evs_exclude.blender("Data.3", c("Data.1", "Data.5"))
)}
)$
set.data(chatty = TRUE)
test.evs$config %>% attributes()
test.evs$.__enclos_env__$private$q_table
test.evs$set.q_graphs(chatty = TRUE)
toc(log = TRUE);
#
tic("EVSpace Universe Validation");
make.evs_universe(
self = test.evs
, mSt >= quantile(mSt, 0.75)
, abs(mGap) >= quantile(mGap, 0.95)
, graph.control = { rlang::exprs(
igraph::E(g)$title	<- igraph::ends(g, igraph::E(g)) %>% apply(1, paste, collapse = " -> ")
, igraph::V(g)$color <- igraph::V(g)$name %>% stringi::stri_split_fixed(":", simplify = TRUE) %>% .[, 1L] %>% {
x = .;
y = purrr::set_names(unique(x), purrr::map_chr(unique(x), ~rgb(runif(1), runif(1), runif(1))))
purrr::map_chr(x, ~names(y)[which(y == .x)])
}
)}
, omit.na = !TRUE
, chatty = TRUE
);
toc(log = TRUE);
test.evs$evt_graphs
g = test.evs$evt_graphs[[1]]
igraph::V(g)$size <- tryCatch({
apply(X = (stringi::stri_split_fixed(V(g)$name,
":", simplify = TRUE))[, c(2, 3)], MARGIN = 1,
FUN = purrr::as_mapper(~as.integer(sqrt(as.numeric(diff(as.Date(.x)))))))
}, error = function(e) {
10
})
igraph::V(g)$title <- purrr::map(igraph::V(g)$name,
stringi::stri_extract_last_regex, pattern = .vnames)
igraph::V(g)$key <- igraph::V(g)$name
igraph::V(g)$name <- igraph::V(g)$name
.vnames <- sprintf("(%s)[:][0-9]+?", paste(test.evs$config$contexts, collapse = "|"));
igraph::V(g)$size <- tryCatch({
apply(X = (stringi::stri_split_fixed(V(g)$name,
":", simplify = TRUE))[, c(2, 3)], MARGIN = 1,
FUN = purrr::as_mapper(~as.integer(sqrt(as.numeric(diff(as.Date(.x)))))))
}, error = function(e) {
10
})
igraph::V(g)$title <- purrr::map(igraph::V(g)$name,
stringi::stri_extract_last_regex, pattern = .vnames)
igraph::V(g)$key <- igraph::V(g)$name
igraph::V(g)$name <- igraph::V(g)$name
.vattrs <- as.list(
purrr::set_names(
append(
purrr::array_branch(stringi::stri_split_fixed(igraph::V(g)$name,":", simplify = TRUE), 2)
, list(title = purrr::map_chr(igraph::V(g)$name, stringi::stri_extract_last_regex, pattern = .vnames))
),
c("jk", "start", "end", "source", "order", "title")))
.vattrs <- append(
purrr::array_branch(stringi::stri_split_fixed(igraph::V(g)$name,":", simplify = TRUE), 2)
, list(title = purrr::map_chr(igraph::V(g)$name, stringi::stri_extract_last_regex, pattern = .vnames))
)
.vattrs
igraph::V(g)$name
.vnames
purrr::map(igraph::V(g)$name, stringi::stri_extract_last_regex, pattern = .vnames)
.vnames
.vnames <- sprintf("(%s).+[0-9]+?", paste(self$config$contexts, collapse = "|"));
.vnames <- sprintf("(%s).+[0-9]+?", paste(test.evs$config$contexts, collapse = "|"));
purrr::map(igraph::V(g)$name, stringi::stri_extract_last_regex, pattern = .vnames)
.vnames
.vnames <- sprintf("(%s).?[0-9]+?", paste(test.evs$config$contexts, collapse = "|"));
purrr::map(igraph::V(g)$name, stringi::stri_extract_last_regex, pattern = .vnames)
.vnames
paste(test.evs$config$contexts, collapse = "|")
igraph::V(g)$name
igraph::V(g)$name %>% duplicated()
BLAH$test_data.01
library(EVSpace)
# ~Initialization ====
# library(EVSpace);
library(purrr)
library(tictoc);
library(future);
plan(tweak(multisession, workers = 5))
#
make.test_data <- function(j = 5, n = 5, m = 5, dest = globalenv(), .debug = FALSE){
#' Make Test Data for Validation
#'
#' \code{make.test_data} creates several \code{\link[data.table]{data.table}} objects to be used to validate the package functionality
#' @param j (integer | 5L) The number of unique values for 'k' to generate
#' @param n (integer | 5L) The number of sources to create (maximum of 5)
#' @param m (integer | 5L) The maximum number of columns to generate for each created object (maximum of 15): each column represents an attribute not related to time
#' @param dest (environment) The destination environment object
#' @param .debug (logical | \code{FALSE}) When \code{TRUE}, additional debugging items are printed
#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 5, 5, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0"))) %>%
purrr::map(~{
set.seed(sample(1:10000, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(jk = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(jk), lambda = sample(1:100, length(jk), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(jk)) > 0.65
] %>%
data.table::setkey(jk, src, date.start, date.end) %>%
data.table::setcolorder(c("jk", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
BLAH <- new.env();
make.test_data(j = 5, n = 5, m = 5, dest = BLAH, .debug = !TRUE);
set.seed(sample(100000, 1));
# ~ Create EVSpace object from test data
tic.clear(); tic.clearlog();
# ~ Validation #1 ====
tic("EVSpace Validation Object");
#
test.evs <- event.vector.space$new();
test.evs$
configure(
src.names			= paste0("BLAH$", ls(pattern = "^test_data", envir = BLAH))
, contexts		= paste0("Src", 1:length(ls(pattern = "^test_data", envir = BLAH)))
, map.fields	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~c("jk", "date.start", "date.end"))
, row.filters	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~rlang::expr(1==1))
, src.mix 		= "combn"
, chatty			= TRUE
, exclude.mix = { c(
evs_exclude.blender("Data.6", c("Data.4", "Data.7"))
, evs_exclude.blender("Data.3", c("Data.1", "Data.5"))
)}
)$
set.data(chatty = TRUE)
test.evs$config %>% attributes()
test.evs$.__enclos_env__$private$q_table
test.evs$set.q_graphs(chatty = TRUE)
toc(log = TRUE);
#
# ~ Validation #2 ====
tic("EVSpace Universe Validation");
make.evs_universe(
self = test.evs
, mSt >= quantile(mSt, 0.75)
, abs(mGap) >= quantile(mGap, 0.95)
, graph.control = { rlang::exprs(
igraph::E(g)$title	<- igraph::ends(g, igraph::E(g)) %>% apply(1, paste, collapse = " -> ")
, igraph::V(g)$color <- igraph::V(g)$name %>% stringi::stri_split_fixed(":", simplify = TRUE) %>% .[, 1L] %>% {
x = .;
y = purrr::set_names(unique(x), purrr::map_chr(unique(x), ~rgb(runif(1), runif(1), runif(1))))
purrr::map_chr(x, ~names(y)[which(y == .x)])
}
)}
, omit.na = !TRUE
, chatty = TRUE
);
toc(log = TRUE);
#
test.evs <- event.vector.space$new();
test.evs$
configure(
src.names			= paste0("BLAH$", ls(pattern = "^test_data", envir = BLAH))
, contexts		= paste0("Src", 1:length(ls(pattern = "^test_data", envir = BLAH)))
, map.fields	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~c("jk", "date.start", "date.end"))
, row.filters	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~rlang::expr(1==1))
, src.mix 		= "combn"
, chatty			= TRUE
, exclude.mix = { c(
evs_exclude.blender("Data.6", c("Data.4", "Data.7"))
, evs_exclude.blender("Data.3", c("Data.1", "Data.5"))
)}
)$
set.data(chatty = TRUE)
View(BLAH)
test.evs$config %>% attributes()
test.evs$.__enclos_env__$private$q_table
test.evs$set.q_graphs(chatty = TRUE)
#
# ~ Validation #2 ====
tic("EVSpace Universe Validation");
make.evs_universe(
self = test.evs
, mSt >= quantile(mSt, 0.75)
, abs(mGap) >= quantile(mGap, 0.95)
, graph.control = { rlang::exprs(
igraph::E(g)$title	<- igraph::ends(g, igraph::E(g)) %>% apply(1, paste, collapse = " -> ")
, igraph::V(g)$color <- igraph::V(g)$name %>% stringi::stri_split_fixed(":", simplify = TRUE) %>% .[, 1L] %>% {
x = .;
y = purrr::set_names(unique(x), purrr::map_chr(unique(x), ~rgb(runif(1), runif(1), runif(1))))
purrr::map_chr(x, ~names(y)[which(y == .x)])
}
)}
, omit.na = !TRUE
, chatty = TRUE
);
toc(log = TRUE);
library(EVSpace)
# ~Initialization ====
# library(EVSpace);
library(purrr)
library(tictoc);
library(future);
plan(tweak(multisession, workers = 5))
#
make.test_data <- function(j = 5, n = 5, m = 5, dest = globalenv(), .debug = FALSE){
#' Make Test Data for Validation
#'
#' \code{make.test_data} creates several \code{\link[data.table]{data.table}} objects to be used to validate the package functionality
#' @param j (integer | 5L) The number of unique values for 'k' to generate
#' @param n (integer | 5L) The number of sources to create (maximum of 5)
#' @param m (integer | 5L) The maximum number of columns to generate for each created object (maximum of 15): each column represents an attribute not related to time
#' @param dest (environment) The destination environment object
#' @param .debug (logical | \code{FALSE}) When \code{TRUE}, additional debugging items are printed
#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 5, 5, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0"))) %>%
purrr::map(~{
set.seed(sample(1:10000, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(jk = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(jk), lambda = sample(1:100, length(jk), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(jk)) > 0.65
] %>%
data.table::setkey(jk, src, date.start, date.end) %>%
data.table::setcolorder(c("jk", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
BLAH <- new.env();
make.test_data(j = 5, n = 5, m = 5, dest = BLAH, .debug = !TRUE);
set.seed(sample(100000, 1));
# ~ Create EVSpace object from test data
tic.clear(); tic.clearlog();
# ~ Validation #1 ====
tic("EVSpace Validation Object");
#
test.evs <- event.vector.space$new();
test.evs$
configure(
src.names			= paste0("BLAH$", ls(pattern = "^test_data", envir = BLAH))
, contexts		= paste0("Src", 1:length(ls(pattern = "^test_data", envir = BLAH)))
, map.fields	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~c("jk", "date.start", "date.end"))
, row.filters	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~rlang::expr(1==1))
, src.mix 		= "combn"
, chatty			= TRUE
, exclude.mix = { c(
evs_exclude.blender("Data.6", c("Data.4", "Data.7"))
, evs_exclude.blender("Data.3", c("Data.1", "Data.5"))
)}
)$
set.data(chatty = TRUE)
test.evs$config %>% attributes()
test.evs$.__enclos_env__$private$q_table
test.evs$set.q_graphs(chatty = TRUE)
toc(log = TRUE);
#
tic("EVSpace Universe Validation");
make.evs_universe(
self = test.evs
, mSt >= quantile(mSt, 0.75)
, abs(mGap) >= quantile(mGap, 0.95)
, graph.control = { rlang::exprs(
igraph::E(g)$title	<- igraph::ends(g, igraph::E(g)) %>% apply(1, paste, collapse = " -> ")
, igraph::V(g)$color <- igraph::V(g)$name %>% stringi::stri_split_fixed(":", simplify = TRUE) %>% .[, 1L] %>% {
x = .;
y = purrr::set_names(unique(x), purrr::map_chr(unique(x), ~rgb(runif(1), runif(1), runif(1))))
purrr::map_chr(x, ~names(y)[which(y == .x)])
}
)}
, omit.na = !TRUE
, chatty = TRUE
);
toc(log = TRUE);
#
test.evs <- event.vector.space$new();
test.evs$
configure(
src.names			= paste0("BLAH$", ls(pattern = "^test_data", envir = BLAH))
, contexts		= paste0("Src", 1:length(ls(pattern = "^test_data", envir = BLAH)))
, map.fields	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~c("jk", "date.start", "date.end"))
, row.filters	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~rlang::expr(1==1))
, src.mix 		= "combn"
, chatty			= TRUE
, exclude.mix = { c(
evs_exclude.blender("Data.6", c("Data.4", "Data.7"))
, evs_exclude.blender("Data.3", c("Data.1", "Data.5"))
)}
)$
set.data(chatty = TRUE)
test.evs$config %>% attributes()
test.evs$.__enclos_env__$private$q_table
test.evs$set.q_graphs(chatty = TRUE)
make.evs_universe(
self = test.evs
, mSt >= quantile(mSt, 0.75)
, abs(mGap) >= quantile(mGap, 0.95)
, graph.control = { rlang::exprs(
igraph::E(g)$title	<- igraph::ends(g, igraph::E(g)) %>% apply(1, paste, collapse = " -> ")
, igraph::V(g)$color <- igraph::V(g)$name %>% stringi::stri_split_fixed(":", simplify = TRUE) %>% .[, 1L] %>% {
x = .;
y = purrr::set_names(unique(x), purrr::map_chr(unique(x), ~rgb(runif(1), runif(1), runif(1))))
purrr::map_chr(x, ~names(y)[which(y == .x)])
}
)}
, omit.na = !TRUE
, chatty = TRUE
);
library(EVSpace)
# ~Initialization ====
# library(EVSpace);
library(purrr)
library(tictoc);
library(future);
plan(tweak(multisession, workers = 5))
#
make.test_data <- function(j = 5, n = 5, m = 5, dest = globalenv(), .debug = FALSE){
#' Make Test Data for Validation
#'
#' \code{make.test_data} creates several \code{\link[data.table]{data.table}} objects to be used to validate the package functionality
#' @param j (integer | 5L) The number of unique values for 'k' to generate
#' @param n (integer | 5L) The number of sources to create (maximum of 5)
#' @param m (integer | 5L) The maximum number of columns to generate for each created object (maximum of 15): each column represents an attribute not related to time
#' @param dest (environment) The destination environment object
#' @param .debug (logical | \code{FALSE}) When \code{TRUE}, additional debugging items are printed
#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 5, 5, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0"))) %>%
purrr::map(~{
set.seed(sample(1:10000, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(jk = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(jk), lambda = sample(1:100, length(jk), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(jk)) > 0.65
] %>%
data.table::setkey(jk, src, date.start, date.end) %>%
data.table::setcolorder(c("jk", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
BLAH <- new.env();
make.test_data(j = 5, n = 5, m = 5, dest = BLAH, .debug = !TRUE);
set.seed(sample(100000, 1));
# ~ Create EVSpace object from test data
tic.clear(); tic.clearlog();
# ~ Validation #1 ====
tic("EVSpace Validation Object");
#
test.evs <- event.vector.space$new();
test.evs$
configure(
src.names			= paste0("BLAH$", ls(pattern = "^test_data", envir = BLAH))
, contexts		= paste0("Src", 1:length(ls(pattern = "^test_data", envir = BLAH)))
, map.fields	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~c("jk", "date.start", "date.end"))
, row.filters	= purrr::map(sequence(length(ls(pattern = "^test_data", envir = BLAH))), ~rlang::expr(1==1))
, src.mix 		= "combn"
, chatty			= TRUE
, exclude.mix = { c(
evs_exclude.blender("Data.6", c("Data.4", "Data.7"))
, evs_exclude.blender("Data.3", c("Data.1", "Data.5"))
)}
)$
set.data(chatty = TRUE)
test.evs$config %>% attributes()
test.evs$.__enclos_env__$private$q_table
test.evs$set.q_graphs(chatty = TRUE)
toc(log = TRUE);
#
tic("EVSpace Universe Validation");
make.evs_universe(
self = test.evs
, mSt >= quantile(mSt, 0.75)
, abs(mGap) >= quantile(mGap, 0.95)
, graph.control = { rlang::exprs(
igraph::E(g)$title	<- igraph::ends(g, igraph::E(g)) %>% apply(1, paste, collapse = " -> ")
, igraph::V(g)$color <- igraph::V(g)$name %>% stringi::stri_split_fixed(":", simplify = TRUE) %>% .[, 1L] %>% {
x = .;
y = purrr::set_names(unique(x), purrr::map_chr(unique(x), ~rgb(runif(1), runif(1), runif(1))))
purrr::map_chr(x, ~names(y)[which(y == .x)])
}
)}
, omit.na = !TRUE
, chatty = TRUE
);
toc(log = TRUE);
test.evs$space[, .(jk, from.coord, to.coord, src.pair, mSt, mGap, mEd, epsilon = as.character(epsilon))] %>% summarytools::dfSummary()
test.evs$space %>% View()
test.evs$evt_graphs[[1]]
test.evs$evt_graphs[[1]] %>% igraph::vertex.attributes()
test.evs$evt_graphs %>% sample(1) %>% igraph::vertex.attributes()
test.evs$evt_graphs %>% sample(1) %>% .[[1]] %>% igraph::vertex.attributes()
test.evs$evt_graphs %>% sample(1) %>% igraph::vertex.attributes()
test.evs$evt_graphs %>% sample(1) %>% .[[1]] %>% igraph::vertex.attributes()
test.evs$evt_graphs %>% sample(1) %>% .[[1]]
test.evs$evt_graphs %>% sample(1) %>% .[[1]] %>% igraph::V()
