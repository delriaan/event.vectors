#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 10, 10, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
o = { ifelse(rlang::has_length(o, 1L)
, yes = 1:10
, no = ifelse(any(o <= 0)
, yes = abs(o)
, no = ifelse(rlang::has_length(o, 2L)
, yes = `:`(o[1], o[2]) |> sort()
, no =  o))
)}
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0")))|>
purrr::map(~{
set.seed(sample(.Random.seed, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(join_key = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(join_key), lambda = sample(o, length(join_key), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(join_key)) > 0.65
] %>%
data.table::setkey(join_key, src, date.start, date.end) %>%
data.table::setcolorder(c("join_key", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
BLAH <- new.env();
set.seed(sample(100000, 1));
make.test_data(j = 50, n = 3, m = 5, o = c(5, 20), dest = BLAH, .debug = !TRUE);set.seed(sample(100000, 1));
set.seed(sample(100000, 1));
make.test_data(j = 50, n = 3, m = 5, o = c(5, 20), dest = .GlobalEnv, .debug = !TRUE);
tic.clear(); tic.clearlog();
library(event.vectors);
library(purrr)
library(stringi)
library(tictoc);
library(future);
library(magrittr);
library(data.table)
#
# dir(pattern = "^[1-4]{1}.+R$", recursive = TRUE) |> purrr::walk(source)
make.test_data <- function(j = 5, n = 5, m = 5, o = 1:10, dest = globalenv(), .debug = FALSE){
#' Make Test Data for Validation
#'
#' \code{make.test_data} creates several \code{\link[data.table]{data.table}} objects to be used to validate the package functionality
#' @param j (integer | 5L) The number of unique values for 'k' to generate
#' @param n (integer | 5L) The number of sources to create (maximum of 10)
#' @param m (integer | 5L) The maximum number of columns to generate for each created object (maximum of 15): each column represents an attribute not related to time
#' @param o (integer[] | 1:10) A vector of integers sampled to create end dates from a randomly-generated start date
#' @param dest (environment) The destination environment object
#' @param .debug (logical | \code{FALSE}) When \code{TRUE}, additional debugging items are printed
#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 10, 10, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
o = { ifelse(rlang::has_length(o, 1L)
, yes = 1:10
, no = ifelse(any(o <= 0)
, yes = abs(o)
, no = ifelse(rlang::has_length(o, 2L)
, yes = `:`(o[1], o[2]) |> sort()
, no =  o))
)}
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0")))|>
purrr::map(~{
set.seed(sample(.Random.seed, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(join_key = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(join_key), lambda = sample(o, length(join_key), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(join_key)) > 0.65
] %>%
data.table::setkey(join_key, src, date.start, date.end) %>%
data.table::setcolorder(c("join_key", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
BLAH <- new.env();
set.seed(sample(100000, 1));
make.test_data(j = 50, n = 3, m = 5, o = c(5, 20), dest = BLAH, .debug = !TRUE);set.seed(sample(100000, 1));
set.seed(sample(100000, 1));
make.test_data(j = 50, n = 3, m = 5, o = c(5, 20), dest = .GlobalEnv, .debug = !TRUE);
tic.clear(); tic.clearlog();
plan(sequential);
plan(tweak(multisession, workers = 7));
tic("EVSpace Validation Object");
test.evs <- { event.vectors$
new()$
configure(
src.defs = c(ls(pattern = "^test.+[0-9]$") |>
purrr::modify_at(3, ~paste0(.x, "[(join_key > 3)]")) |>
purrr::modify_at(1, ~paste0(.x, "[lubridate::month(date.start)==1]")) |>
rlang::parse_exprs()
, ("BLAH$" %s+% ls(BLAH, pattern = "^test")[1:3]) |>
purrr::modify_at(3, ~paste0(.x, "[(join_key == 1)]")) |>
purrr::modify_at(2, ~paste0(.x, "[lubridate::month(date.start)==8]")) |>
rlang::parse_exprs()
)
, contexts = rlang::parse_exprs("Event_" %s+% LETTERS[1:6])
, map.fields = replicate(n = 6, c("join_key", "date.start", "date.end"), simplify = FALSE)
, chatty = TRUE
)$
make.evs_universe(
# , mSt >= quantile(mSt, 0.75)
# , abs(mGap) >= lubridate::days(5)
# , abs(mGap) <= lubridate::days(120)
, time.control = list(0, 100)
# , graph.control = { rlang::exprs(
# 			igraph::E(g)$title	<- igraph::ends(g, igraph::E(g)) %>% apply(1, paste, collapse = " -> ")
# 			, igraph::V(g)$color <- igraph::V(g)$name %>% stringi::stri_split_fixed(":", simplify = TRUE) %>% .[, 1L] %>% {
# 					x = .;
# 					y = purrr::set_names(unique(x), purrr::map_chr(unique(x), ~rgb(runif(1), runif(1), runif(1))))
# 					purrr::map_chr(x, ~names(y)[which(y == .x)])
# 				}
# 			, igraph::V(g)$src <- igraph::V(g)$name %>% stringi::stri_replace_first_regex("[:][0-9]+", "")
# 			)
# 	}
, units = "days"
, chatty = TRUE
)
}
toc(log = TRUE);
test.evs$config |> attributes();
test.evs$.__enclos_env__$private$q_table;
test.evs$.__enclos_env__$private$.params$config
test.evs$space |> View()
test.evs$space[, .(jk, from.coord, to.coord, src.pair, mSt, mGap, mEd, epsilon = as.character(epsilon))] %>% summarytools::dfSummary() |> summarytools::view(method = "browser");
test.evs$space[(jk == 4)] %>% View("Space: jk == 4");
igraph::vertex.attributes(test.evs$evt_graphs$`1`);
test.evs$evt_graphs$`1` |> igraph::V()
test.evs$evt_graphs$`1` |> igraph::E()
test.evs$evt_graphs$`1` |> igraph::edge.attributes()
# ~ Validation #2 :: visNetwork::visIgraph() ====
f2ab <- list(theta = 0.1, gravitationalConstant = -5000, centralGravity = 0.0,  avoidOverlap = 1, damping = 0.7);
event_graph %>% {
g = .
igraph::V(g)$title <- igraph::V(g)$trace |>
purrr::map_chr(~{
x = eval(.x, envir = globalenv()) %>%
.[, purrr::modify_at(.SD[, !"row.filters"], c("start_idx", "end_idx"), as.character)] %>%
melt(measure.vars = names(.), variable.name = "key", variable.factor = FALSE)
kableExtra::kable(x = x, caption = "Retraced data from source") |>
kableExtra::kable_styling()
})
g
} %>%
visNetwork::visIgraph(physics = TRUE, type = "full") %>%
visNetwork::visPhysics(solver = "forceAtlas2Based", timestep = 0.05) %>%
visNetwork::visOptions(width = "1600", height = "1024") %>%
visNetwork::visNodes(opacity = 0.5) %>%
htmltools::html_print(viewer = browseURL)
test.evs$evt_graphs$`1` |> %>% {
g = .
igraph::V(g)$title <- igraph::V(g)$trace |>
purrr::map_chr(~{
x = eval(.x, envir = globalenv()) %>%
.[, purrr::modify_at(.SD[, !"row.filters"], c("start_idx", "end_idx"), as.character)] %>%
melt(measure.vars = names(.), variable.name = "key", variable.factor = FALSE)
kableExtra::kable(x = x, caption = "Retraced data from source") |>
kableExtra::kable_styling()
})
g
} %>%
visNetwork::visIgraph(physics = TRUE, type = "full") %>%
visNetwork::visPhysics(solver = "forceAtlas2Based", timestep = 0.05) %>%
visNetwork::visOptions(width = "1600", height = "1024") %>%
visNetwork::visNodes(opacity = 0.5) %>%
htmltools::html_print(viewer = browseURL)
test.evs$evt_graphs$`1` %>% {
g = .
igraph::V(g)$title <- igraph::V(g)$trace |>
purrr::map_chr(~{
x = eval(.x, envir = globalenv()) %>%
.[, purrr::modify_at(.SD[, !"row.filters"], c("start_idx", "end_idx"), as.character)] %>%
melt(measure.vars = names(.), variable.name = "key", variable.factor = FALSE)
kableExtra::kable(x = x, caption = "Retraced data from source") |>
kableExtra::kable_styling()
})
g
} %>%
visNetwork::visIgraph(physics = TRUE, type = "full") %>%
visNetwork::visPhysics(solver = "forceAtlas2Based", timestep = 0.05) %>%
visNetwork::visOptions(width = "1600", height = "1024") %>%
visNetwork::visNodes(opacity = 0.5) %>%
htmltools::html_print(viewer = browseURL)
# ~ Validation #3 :: continuity ----
inspect <- continuity.dev(
data = copy(test_data.01)[, `:=`(Z_1 = sample(letters, .N, TRUE), Z_2 = sample(LETTERS[1:5], .N, TRUE))]
, map_fields = c(join_key, Z_1, Z_2)
, time_fields = c(date.start, date.end)
, boundary_name = episode
, timeout = 10
, archipelago = TRUE
, show.all = TRUE
)
# ~ Validation #3 :: continuity ----
inspect <- continuity(
data = copy(test_data.01)[, `:=`(Z_1 = sample(letters, .N, TRUE), Z_2 = sample(LETTERS[1:5], .N, TRUE))]
, map_fields = c(join_key, Z_1, Z_2)
, time_fields = c(date.start, date.end)
, boundary_name = episode
, timeout = 10
, archipelago = TRUE
, show.all = TRUE
)
View(inspect)
library(event.vectors)
# ~ Initialization ====
# library(event.vectors);
library(purrr)
library(stringi)
library(tictoc);
library(future);
library(magrittr);
library(data.table)
#
# dir(pattern = "^[1-4]{1}.+R$", recursive = TRUE) |> purrr::walk(source)
make.test_data <- function(j = 5, n = 5, m = 5, o = 1:10, dest = globalenv(), .debug = FALSE){
#' Make Test Data for Validation
#'
#' \code{make.test_data} creates several \code{\link[data.table]{data.table}} objects to be used to validate the package functionality
#' @param j (integer | 5L) The number of unique values for 'k' to generate
#' @param n (integer | 5L) The number of sources to create (maximum of 10)
#' @param m (integer | 5L) The maximum number of columns to generate for each created object (maximum of 15): each column represents an attribute not related to time
#' @param o (integer[] | 1:10) A vector of integers sampled to create end dates from a randomly-generated start date
#' @param dest (environment) The destination environment object
#' @param .debug (logical | \code{FALSE}) When \code{TRUE}, additional debugging items are printed
#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 10, 10, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
o = { ifelse(rlang::has_length(o, 1L)
, yes = 1:10
, no = ifelse(any(o <= 0)
, yes = abs(o)
, no = ifelse(rlang::has_length(o, 2L)
, yes = `:`(o[1], o[2]) |> sort()
, no =  o))
)}
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0")))|>
purrr::map(~{
set.seed(sample(.Random.seed, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(join_key = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(join_key), lambda = sample(o, length(join_key), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(join_key)) > 0.65
] %>%
data.table::setkey(join_key, src, date.start, date.end) %>%
data.table::setcolorder(c("join_key", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
BLAH <- new.env();
set.seed(sample(100000, 1));
make.test_data(j = 50, n = 3, m = 5, o = c(5, 20), dest = BLAH, .debug = !TRUE);set.seed(sample(100000, 1));
set.seed(sample(100000, 1));
make.test_data(j = 50, n = 3, m = 5, o = c(5, 20), dest = .GlobalEnv, .debug = !TRUE);
tic.clear(); tic.clearlog();
#
# ~ Validation #1 :: event.vectors ====
plan(sequential);
plan(tweak(multisession, workers = 7));
tic("EVSpace Validation Object");
test.evs <- { event.vectors$
new()$
configure(
src.defs = c(ls(pattern = "^test.+[0-9]$") |>
purrr::modify_at(3, ~paste0(.x, "[(join_key > 3)]")) |>
purrr::modify_at(1, ~paste0(.x, "[lubridate::month(date.start)==1]")) |>
rlang::parse_exprs()
, ("BLAH$" %s+% ls(BLAH, pattern = "^test")[1:3]) |>
purrr::modify_at(3, ~paste0(.x, "[(join_key == 1)]")) |>
purrr::modify_at(2, ~paste0(.x, "[lubridate::month(date.start)==8]")) |>
rlang::parse_exprs()
)
, contexts = rlang::parse_exprs("Event_" %s+% LETTERS[1:6])
, map.fields = replicate(n = 6, c("join_key", "date.start", "date.end"), simplify = FALSE)
, chatty = TRUE
)$
make.evs_universe(
# , mSt >= quantile(mSt, 0.75)
# , abs(mGap) >= lubridate::days(5)
# , abs(mGap) <= lubridate::days(120)
, time.control = list(0, 100)
# , graph.control = { rlang::exprs(
# 			igraph::E(g)$title	<- igraph::ends(g, igraph::E(g)) %>% apply(1, paste, collapse = " -> ")
# 			, igraph::V(g)$color <- igraph::V(g)$name %>% stringi::stri_split_fixed(":", simplify = TRUE) %>% .[, 1L] %>% {
# 					x = .;
# 					y = purrr::set_names(unique(x), purrr::map_chr(unique(x), ~rgb(runif(1), runif(1), runif(1))))
# 					purrr::map_chr(x, ~names(y)[which(y == .x)])
# 				}
# 			, igraph::V(g)$src <- igraph::V(g)$name %>% stringi::stri_replace_first_regex("[:][0-9]+", "")
# 			)
# 	}
, units = "days"
, chatty = TRUE
)
}
toc(log = TRUE);
test.evs$config |> attributes();
test.evs$.__enclos_env__$private$q_table;
test.evs$.__enclos_env__$private$.params$config
test.evs$space |> View()
test.evs$space[, .(jk, from.coord, to.coord, src.pair, mSt, mGap, mEd, epsilon = as.character(epsilon))] %>% summarytools::dfSummary() |> summarytools::view(method = "browser");
test.evs$space[(jk == 4)] %>% View("Space: jk == 4");
igraph::vertex.attributes(test.evs$evt_graphs$`1`);
test.evs$evt_graphs$`1` |> igraph::V()
test.evs$evt_graphs$`1` |> igraph::E()
test.evs$evt_graphs$`1` |> igraph::edge.attributes()
# ~ Validation #2 :: visNetwork::visIgraph() ====
f2ab <- list(theta = 0.1, gravitationalConstant = -5000, centralGravity = 0.0,  avoidOverlap = 1, damping = 0.7);
test.evs$evt_graphs$`1` %>% {
g = .
igraph::V(g)$title <- igraph::V(g)$trace |>
purrr::map_chr(~{
x = eval(.x, envir = globalenv()) %>%
.[, purrr::modify_at(.SD[, !"row.filters"], c("start_idx", "end_idx"), as.character)] %>%
melt(measure.vars = names(.), variable.name = "key", variable.factor = FALSE)
kableExtra::kable(x = x, caption = "Retraced data from source") |>
kableExtra::kable_styling()
})
g
} %>%
visNetwork::visIgraph(physics = TRUE, type = "full") %>%
visNetwork::visPhysics(solver = "forceAtlas2Based", timestep = 0.05) %>%
visNetwork::visOptions(width = "1600", height = "1024") %>%
visNetwork::visNodes(opacity = 0.5) %>%
htmltools::html_print(viewer = browseURL)
# ~ Validation #3 :: continuity ----
inspect <- continuity(
data = copy(test_data.01)[, `:=`(Z_1 = sample(letters, .N, TRUE), Z_2 = sample(LETTERS[1:5], .N, TRUE))]
, map_fields = c(join_key, Z_1, Z_2)
, time_fields = c(date.start, date.end)
, boundary_name = episode
, timeout = 10
, archipelago = TRUE
, show.all = TRUE
)
View(inspect)
#
#
# ~ Validation #4 :: retrace.evs ====
retrace.evs(test.evs$evt_graphs[1], test.evs)
#
# ~ Validation #4 :: retrace.evs ====
retrace.evs(test.evs$evt_graphs[[1]], test.evs)
library(event.vectors);
# ~ Initialization ====
# library(event.vectors);
library(purrr);
library(stringi);
library(tictoc);
library(future);
library(magrittr);
library(data.table);
# dir(pattern = "^[1-4]{1}.+R$", recursive = TRUE) |> purrr::walk(source)
make.test_data <- function(j = 5, n = 5, m = 5, o = 1:10, dest = globalenv(), .debug = FALSE){
#' Make Test Data for Validation
#'
#' \code{make.test_data} creates several \code{\link[data.table]{data.table}} objects to be used to validate the package functionality
#' @param j (integer | 5L) The number of unique values for 'k' to generate
#' @param n (integer | 5L) The number of sources to create (maximum of 10)
#' @param m (integer | 5L) The maximum number of columns to generate for each created object (maximum of 15): each column represents an attribute not related to time
#' @param o (integer[] | 1:10) A vector of integers sampled to create end dates from a randomly-generated start date
#' @param dest (environment) The destination environment object
#' @param .debug (logical | \code{FALSE}) When \code{TRUE}, additional debugging items are printed
#'
#' @return One to \code{n} \code{\link[data.table]{data.table}} objects prefixed as 'test_data'.
#'
j = max(c(3, abs(as.integer(j))));
n = max(c(3, abs(as.integer(n)))); ifelse(n > 10, 10, n);
m = max(c(3, abs(as.integer(m)))); ifelse(m > 15, 15, m);
o = { ifelse(rlang::has_length(o, 1L)
, yes = 1:10
, no = ifelse(any(o <= 0)
, yes = abs(o)
, no = ifelse(rlang::has_length(o, 2L)
, yes = `:`(o[1], o[2]) |> sort()
, no =  o))
)}
sequence(n) %>%
purrr::set_names(paste0("test_data.", stringi::stri_pad_left(., width = 2, pad = "0")))|>
purrr::map(~{
set.seed(sample(.Random.seed, 1));
.src = LETTERS[[.x]];
.out = purrr::map_dfr(c(1:j), ~list(join_key = rep.int(.x, sample(10:100, 1, TRUE)), src = .src)) %>% data.table::as.data.table();
.init_date = c(as.Date(sprintf(
"%s-%s-%s"
, rep.int(data.table::year(Sys.Date()), nrow(.out))
, sample(stringi::stri_pad_left(1:12, width = 2, pad = "0"), nrow(.out), TRUE)
, sample(stringi::stri_pad_left(1:28, width = 2, pad = "0"), nrow(.out), TRUE)
)));
.out[
, c("date.start", "date.end") := list(.init_date, .init_date + rpois(n = length(join_key), lambda = sample(o, length(join_key), TRUE)))
][
, paste0("X_", stringi::stri_pad_left(sample(30, m), width = 2, pad = "0")) := purrr::map(1:m, ~sample(runif(1E6), .N, TRUE))
][
runif(length(join_key)) > 0.65
] %>%
data.table::setkey(join_key, src, date.start, date.end) %>%
data.table::setcolorder(c("join_key", "date.start", "date.end", "src"))
}) %>%
list2env(envir = dest);
}
BLAH <- new.env();
set.seed(sample(100000, 1));
make.test_data(j = 50, n = 3, m = 5, o = c(5, 20), dest = BLAH, .debug = !TRUE);set.seed(sample(100000, 1));
set.seed(sample(100000, 1));
make.test_data(j = 50, n = 3, m = 5, o = c(5, 20), dest = .GlobalEnv, .debug = !TRUE);
tic.clear(); tic.clearlog();
# usethis::use_pkgdown()
# pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
usethis::use_github_pages()
gh_token_help()
usethis::gh_token_help()
dir()
getwd()
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(event.vectors)
library(event.vectors)
library(event.vectors)
library(event.vectors)
library(event.vectors)
library(event.vectors)
library(event.vectors)
library(event.vectors)
library(event.vectors)
library(event.vectors)
library(event.vectors)
library(event.vectors)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(event.vectors)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(event.vectors)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(event.vectors)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", examples = FALSE, override = list(destination = "../docs"))
usethis::use_proprietary_license("Chionesu George")
usethis::use_proprietary_license("Chionesu George")
library(event.vectors)
# ----
# usethis::use_pkgdown()
# usethis::use_proprietary_license("Chionesu George")
pkgdown::build_site(pkg = "pkg", examples = FALSE, override = list(destination = "../docs"))
# ----
# usethis::use_pkgdown()
# usethis::use_proprietary_license("Chionesu George")
pkgdown::build_site(pkg = "pkg", examples = FALSE, override = list(destination = "../docs"))
pkgdown::build_site_github_pages(pkg = "pkg", dest_dir = "docs", clean = TRUE, new_process = TRUE)
pkgdown::build_site_github_pages(pkg = "pkg", dest_dir = "docs", clean = TRUE, new_process = TRUE)
pkgdown::build_site_github_pages(pkg = "pkg", dest_dir = "../docs", clean = TRUE, new_process = TRUE)
# ----
# usethis::use_pkgdown()
# usethis::use_proprietary_license("Chionesu George")
pkgdown::build_site(pkg = "pkg", examples = FALSE, override = list(destination = "../docs"))
# ~ Initialization ====
# library(event.vectors);
library(purrr)
usethis::use_pkgdown()
usethis::use_pkgdown()
setwd("D:/Imperial Git Repos/event.vectors/pkg")
usethis::use_pkgdown()
setwd("D:/Imperial Git Repos/event.vectors")
# ----
# usethis::use_pkgdown()
# usethis::use_proprietary_license("Chionesu George")
pkgdown::build_site(pkg = "pkg", examples = FALSE, override = list(destination = "../docs"))
usethis::use_pkgdown()
# ----
# usethis::use_pkgdown()
# usethis::use_proprietary_license("Chionesu George")
pkgdown::build_site(pkg = "pkg", examples = FALSE, override = list(destination = "../docs"))
